# Feature 0010: Migrate to Django's AbstractUser Model

## Overview

Migrate the custom User model (`src.core.models.User`) to extend Django's `AbstractUser` while preserving the Telegram-specific field `telegram_id` and other app-specific fields (`active`, `language`). This enables full Django authentication features (login, permissions, password management) for future web interfaces while maintaining backward compatibility with the existing Telegram bot implementation.

## Current State

**Custom User Model** (`src/core/models.User` at `src/core/models.py:7-43`):
- Standalone Django model with custom fields only
- Fields: `id`, `telegram_id`, `name`, `active`, `language`, `created_at`, `updated_at`
- No Django authentication integration
- Works fine for Telegram bot, but lacks Django auth features

**Related Models** using ForeignKey to current User:
- `RewardProgress` (`src/core/models.py:136-206`) - `user` ForeignKey
- `HabitLog` (`src/core/models.py:208-264`) - `user` ForeignKey

**Repositories** (`src/core/repositories.py`):
- `UserRepository` (`src/core/repositories.py:18-77`) - Uses `User.objects` ORM queries
- All methods work with `telegram_id` as the primary lookup field

**Admin Interface** (`src/core/admin.py:7-25`):
- `UserAdmin` registered for current User model
- List display includes `telegram_id`, `name`, `active`, `language`, `created_at`

## Changes Required

### Phase 1: Data Model Layer

#### 1.1. Update User Model (`src/core/models.py:7-43`)

Replace the current custom User model with AbstractUser-based implementation:

**Fields to add from AbstractUser:**
- `username` (CharField, unique) - Required by AbstractUser
- `email` (EmailField, optional for Telegram bot)
- `password` (CharField) - Django password hash
- `first_name`, `last_name` (CharField, optional)
- `is_staff`, `is_superuser`, `is_active` (BooleanField) - Django admin permissions
- `date_joined` (DateTimeField) - Django default timestamp
- Plus all Django auth infrastructure fields

**Custom fields to preserve:**
- `telegram_id` (CharField, max_length=50, unique=True, db_index=True) - Keep as-is
- `name` (CharField, max_length=255) - Keep for display purposes (separate from first_name/last_name)
- `active` (BooleanField) - **CONFLICT**: Django's AbstractUser already has `is_active`
  - **Solution**: Map bot's `active` field to Django's `is_active` field, or rename to `telegram_active`
- `language` (CharField, max_length=2, choices=[...]) - Keep as-is

**Fields to migrate/map:**
- `created_at` → Use Django's `date_joined` field (auto_now_add=True)
- `updated_at` → Keep as-is with auto_now=True
- `active` → Map to Django's `is_active` field (both BooleanField, default=False)

**Set `username` strategy:**
Use Django's default `username` field behavior (CharField, unique, required by AbstractUser). For Telegram bot users, auto-generate username from `telegram_id`:
- Pattern: `username = f"tg_{telegram_id}"` (e.g., "tg_123456789")
- This ensures uniqueness and keeps username as Django's authentication identifier
- `telegram_id` remains a separate custom field (CharField, max_length=50, unique=True, db_index=True)

#### 1.2. Update Settings (`src/habit_reward_project/settings.py:41-51`)

Add `AUTH_USER_MODEL` setting to specify custom user model:

```python
# After INSTALLED_APPS
AUTH_USER_MODEL = 'core.User'
```

This must be set **before any migrations are created**.

#### 1.3. Create Migration

Generate new migration to replace existing User table:

**Step-by-step migration strategy:**

1. **Data preservation**: Create data migration to backup existing user data
2. **Drop old constraints**: Remove ForeignKey constraints from `RewardProgress` and `HabitLog`
3. **Replace User model**: Drop existing `users` table, create new AbstractUser-based table
4. **Restore data**: Migrate data from backup, mapping fields:
   - `id` → `id` (preserve primary keys to maintain FK relationships)
   - `telegram_id` → `telegram_id`
   - `name` → `name` (keep custom field)
   - `active` → `is_active` (map to Django field)
   - `language` → `language`
   - `created_at` → `date_joined`
   - `updated_at` → `updated_at`
   - Set `username = f"tg_{telegram_id}"` for each user (auto-generated from telegram_id)
   - Set `password = ''` (unusable password) for Telegram-only users
5. **Restore FK constraints**: Recreate ForeignKey relationships

**Note:** This is a destructive migration. Existing database will need to be backed up or recreated.

### Phase 2: Repository & Service Layer

#### 2.1. Update UserRepository (`src/core/repositories.py:18-77`)

**No changes required** if field mapping is handled correctly:
- `get_by_telegram_id()` - Works as-is (telegram_id unchanged)
- `get_by_id()` - Works as-is (primary key unchanged)
- `create()` - Update to map `active` → `is_active`, set default `username=telegram_id`
- `update()` - Update to map `active` → `is_active` if present in updates dict

**Field mapping in repository methods:**

```python
# In create() method - map bot fields to Django auth fields
def create(self, user: User | dict) -> User:
    if isinstance(user, dict):
        # Map 'active' to 'is_active'
        if 'active' in user:
            user['is_active'] = user.pop('active')
        # Auto-generate username from telegram_id if not provided
        if 'username' not in user and 'telegram_id' in user:
            user['username'] = f"tg_{user['telegram_id']}"
        return User.objects.create(**user)
    # ... similar mapping for User instance
```

#### 2.2. Update Service Layer

**Files to review but likely no changes:**
- `src/services/habit_service.py` - Uses repositories, no direct User model access
- `src/services/reward_service.py` - Uses repositories, no direct User model access
- `src/services/streak_service.py` - Uses repositories, no direct User model access

**Only update if services directly access User fields:**
- Change `user.active` → `user.is_active` (if accessed directly)

### Phase 3: Admin & Bot Handlers

#### 3.1. Update Django Admin (`src/core/admin.py:7-25`)

Replace `UserAdmin` to extend Django's built-in `UserAdmin`:

**Import Django's UserAdmin:**
```python
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
```

**Extend BaseUserAdmin** to include custom fields:
- Add `telegram_id`, `language` to `list_display`
- Add `telegram_id`, `language` to `fieldsets`
- Remove `active` from display (use `is_active` instead)
- Keep `search_fields` for `telegram_id` and `name`

#### 3.2. Update Bot Handlers

**Files that access `user.active`:**
- Review all bot handlers in `src/bot/handlers/` that check `user.active`
- Update to use `user.is_active` instead

**Likely affected files** (grep for `user.active`):
- `src/bot/main.py`
- `src/bot/handlers/*.py`

**Change pattern:**
```python
# Before
if not user.active:
    await update.message.reply_text(msg('ERROR_USER_INACTIVE', lang))
    return

# After
if not user.is_active:
    await update.message.reply_text(msg('ERROR_USER_INACTIVE', lang))
    return
```

### Phase 4: Testing & Validation

#### 4.1. Update Tests

**Files to update:**
- `tests/test_bot_handlers.py` - Update user fixtures to use `is_active` instead of `active`
- `tests/test_habit_service.py` - Update user creation in fixtures
- `tests/test_repositories.py` - Update user repository tests

**Test fixtures to update:**
```python
# Before
user = User(telegram_id="123", name="Test", active=True)

# After
user = User(telegram_id="123", name="Test", is_active=True, username="tg_123")
```

#### 4.2. Update Pydantic Model (Legacy/Airtable)

**File:** `src/models/user.py` (Pydantic model for Airtable compatibility)

If still in use for Airtable fallback:
- Keep as-is (separate from Django model)
- Update field validator for `active` to map to/from Django's `is_active` when converting

#### 4.3. Data Migration Script

Create management command to migrate existing users:

**File:** `src/core/management/commands/migrate_users_to_abstractuser.py`

**Algorithm:**
1. Check if using AbstractUser model (verify `AUTH_USER_MODEL`)
2. For each existing user in backup:
   - Map `active` → `is_active`
   - Generate `username = f"tg_{telegram_id}"` (auto-generated from telegram_id)
   - Set `password` to unusable password using `user.set_unusable_password()`
   - Preserve `telegram_id`, `name`, `language` as custom fields
   - Map `created_at` → `date_joined`
3. Validate all ForeignKey relationships intact

## Files to Modify

### Data Layer
- `src/core/models.py:7-43` - Replace User model with AbstractUser-based version
- `src/habit_reward_project/settings.py:41-51` - Add `AUTH_USER_MODEL = 'core.User'`
- New migration file - Data migration for AbstractUser

### Repository Layer
- `src/core/repositories.py:18-77` - Update UserRepository field mapping (`active` → `is_active`)

### Admin Layer
- `src/core/admin.py:7-25` - Extend Django's UserAdmin instead of ModelAdmin

### Bot Handlers (Field Access Updates)
- `src/bot/main.py` - Update `user.active` → `user.is_active`
- `src/bot/handlers/*.py` - Update all files that check `user.active`

### Testing
- `tests/test_bot_handlers.py` - Update user fixtures
- `tests/test_habit_service.py` - Update user fixtures
- `tests/test_repositories.py` - Update user repository tests

### Optional
- `src/models/user.py` - Pydantic User model (if still used for Airtable, update field mapping)

## Implementation Notes

**Username Generation Strategy:**
- Keep Django's default `USERNAME_FIELD = 'username'` (no override)
- Auto-generate username from telegram_id using pattern `f"tg_{telegram_id}"`
- Both `username` and `telegram_id` will be unique fields
- Bot handlers continue to use `telegram_id` for lookups (via `UserRepository.get_by_telegram_id()`)
- Django admin can use either username or telegram_id for authentication

**Password Handling:**
- Telegram-only users won't have passwords
- Set unusable password using `user.set_unusable_password()` on creation
- If web interface is added later, users can set passwords through password reset flow

**Backward Compatibility:**
- Repository pattern ensures services don't need changes
- Field mapping in repository handles `active` → `is_active` translation
- ForeignKey relationships preserved by maintaining primary key IDs during migration

**Risk Mitigation:**
- This is a breaking migration - existing database must be backed up
- Test thoroughly in development before applying to production
- Consider creating a reversible migration script
- Document rollback procedure

**Future Benefits:**
- Enable Django admin login for staff users
- Add web dashboard with user authentication
- Use Django's permission and group system
- Integrate with Django REST Framework for API authentication
- Use `@login_required` decorator for web views
