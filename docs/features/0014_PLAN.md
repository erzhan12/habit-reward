# Feature 0014: Configurable Daily Frequency Limits for Rewards

## Description

Implement a flexible daily frequency restriction system for rewards with per-reward configuration. The system should support:

1. **Configurable daily limits per reward**: Each reward has a `max_daily_claims` field (integer)
   - `NULL` or `0` = unlimited (reward can be awarded multiple times per day)
   - `1` = once per day maximum
   - `2+` = that many times per day maximum

2. **Piece-based counting**: For both single-piece and multi-piece rewards, the daily limit counts **pieces awarded today**, not completions
   - A reward with `max_daily_claims=1` can only award 1 piece per day (regardless of pieces_required)
   - A reward with `max_daily_claims=0` (unlimited) can award unlimited pieces per day

3. **Lottery exclusion**: Rewards that have reached their daily limit are excluded from the lottery entirely

4. **Post-claim behavior**: After claiming a completed reward:
   - `pieces_earned` resets to 0
   - `claimed` flag is set to True (then immediately reset to False on next award)
   - Reward becomes eligible again IF its daily limit allows (based on pieces awarded today that are NOT yet claimed)

5. **Daily counter logic**: Count only pieces currently in progress (unclaimed) for the day
   - When a reward is claimed, those pieces don't count toward the daily limit anymore
   - This allows rewards to be "recycled" within the same day if claimed

## Current Implementation Analysis

### Existing Daily Award Prevention
Currently in `src/services/habit_service.py:169-180`:
- `get_todays_awarded_rewards()` returns list of reward IDs awarded today
- `select_reward()` excludes these IDs completely (all-or-nothing exclusion)
- This prevents ANY reward from being selected twice in one day

### Gap in Current Logic
- No per-reward configuration for daily frequency
- No concept of "pieces awarded today" vs "reward selected today"
- Completed rewards (status=ACHIEVED) can still receive pieces if somehow selected
- No way to have some rewards unlimited and others limited

## Technical Requirements

### Phase 1: Database Schema Changes

#### 1.1 Add max_daily_claims Field to Rewards Table

**File**: Create new Django migration

**Changes needed**:
```python
# New migration file: src/core/migrations/XXXX_add_reward_daily_limits.py
from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [
        ('core', 'PREVIOUS_MIGRATION_NAME'),
    ]

    operations = [
        migrations.AddField(
            model_name='reward',
            name='max_daily_claims',
            field=models.IntegerField(
                null=True,
                blank=True,
                help_text="Maximum times this reward can be claimed per day. NULL/0 = unlimited."
            ),
        ),
    ]
```

**Model update** in `src/core/models.py:112-162` (Reward model):
- Add field after `pieces_required` (around line 140):
```python
max_daily_claims = models.IntegerField(
    null=True,
    blank=True,
    help_text="Maximum times this reward can be claimed per day (NULL or 0 = unlimited)"
)
```

#### 1.2 Update Pydantic Reward Model

**File**: Find the Pydantic Reward model (likely in `src/models/reward.py`)

**Changes needed**:
- Add `max_daily_claims: int | None = None` field
- Ensure it's included in model validation

### Phase 2: Core Service Logic Changes

#### 2.1 Create Helper Function to Count Today's Pieces for a Reward

**File**: `src/services/reward_service.py`

**New function** (add around line 145, after `get_todays_awarded_rewards`):

```python
def get_todays_pieces_by_reward(
    self,
    user_id: str,
    reward_id: str
) -> int | Awaitable[int]:
    """
    Count how many pieces of a specific reward were awarded today
    that are still in progress (unclaimed).

    Logic:
    - Query habit_logs for today where user_id matches and reward_id matches
    - Get the current reward_progress for this user/reward
    - If reward is CLAIMED, return 0 (claimed pieces don't count)
    - Otherwise, count pieces earned today (could be inferred from progress
      or counted from logs)

    Returns:
        Number of unclaimed pieces awarded today for this reward
    """
```

**Algorithm**:
1. Get all habit_log entries for today where `user_id=user_id`, `reward_id=reward_id`, `got_reward=True`
2. Get current reward_progress for this user/reward
3. If progress.status == CLAIMED, return 0
4. Otherwise, return count of today's logs (each log = 1 piece)

**Note**: This assumes each habit completion awards at most 1 piece of a reward. If that's not the case, we need to track pieces per log entry.

#### 2.2 Modify select_reward() to Apply Daily Limits

**File**: `src/services/reward_service.py:54-118`

**Current flow**:
1. Get all active rewards
2. Exclude rewards in `exclude_reward_ids` list
3. Perform weighted random selection
4. Return selected reward

**New flow**:
1. Get all active rewards from database
2. Exclude rewards in `exclude_reward_ids` list (for backwards compatibility)
3. **[NEW]** If `user_id` is provided:
   - Fetch user's reward progress for all rewards
   - For each reward:
     - **Check 1**: Exclude if completed (pieces_earned >= pieces_required)
     - **Check 2**: If reward has `max_daily_claims` set (not NULL/0):
       - Count today's unclaimed pieces for this reward using `get_todays_pieces_by_reward()`
       - If count >= max_daily_claims, exclude this reward
   - Log exclusion reasons (completed, daily limit reached, etc.)
4. If no rewards remain, return "No reward"
5. Calculate adjusted weights and perform weighted random selection
6. Return selected reward

**Implementation details**:
- Add logic after line 89 (after initial exclusion filtering)
- Call `self.progress_repo.get_all_by_user(user_id)` to get progress
- For each reward, check both completion status AND daily limit
- Use `get_todays_pieces_by_reward()` to check daily count
- Log detailed exclusion info for debugging

#### 2.3 Update mark_reward_claimed() to Reset Properly

**File**: `src/services/reward_service.py:211-242`

**Current behavior**:
- Sets `claimed=True`
- Does NOT reset `pieces_earned`

**New behavior**:
- Set `claimed=True`
- **[NEW]** Reset `pieces_earned=0`
- This allows the reward to start fresh after claiming
- Note: The daily limit check will still apply based on today's habit_logs

**Changes needed**:
Update the `update()` call (around line 231) to also set `pieces_earned=0`:
```python
updated_progress = await maybe_await(
    self.progress_repo.update(
        progress.id,
        {
            "claimed": True,
            "pieces_earned": 0,  # Reset counter for fresh start
        },
    )
)
```

#### 2.4 Modify update_reward_progress() Claimed Reset Logic

**File**: `src/services/reward_service.py:146-209` (function `update_reward_progress`)

**Current logic** (lines 192-198):
- If status == CLAIMED, reset `claimed=False` and increment pieces

**New logic** should remain similar:
- If status == CLAIMED, reset `claimed=False`
- Continue with normal piece increment
- The daily limit check happens in `select_reward()`, so by the time we reach this function, the reward has already been deemed eligible

**No changes needed** in this function's core logic, but verify it still works with the new `pieces_earned=0` from claiming.

### Phase 3: Update Helper Functions

#### 3.1 Verify get_todays_awarded_rewards() Still Needed

**File**: `src/services/reward_service.py:120-144`

**Current purpose**: Get list of reward IDs awarded today for exclusion

**New purpose**: May still be useful for backwards compatibility or as a fallback, but the new logic uses per-reward daily limits instead.

**Decision**: Keep this function but note that it's now SECONDARY to the max_daily_claims logic. The primary exclusion logic should be the per-reward limit checks.

#### 3.2 Update habit_service.py to Stop Using Simple Exclusion List

**File**: `src/services/habit_service.py:169-183`

**Current code**:
```python
todays_awarded_rewards = await maybe_await(
    self.reward_service.get_todays_awarded_rewards(user.id)
)

selected_reward = await maybe_await(
    self.reward_service.select_reward(
        total_weight=total_weight,
        user_id=user.id,
        exclude_reward_ids=todays_awarded_rewards
    )
)
```

**New code**:
```python
# No longer need to pass exclude_reward_ids - the daily limit logic
# is now handled internally in select_reward() based on max_daily_claims
selected_reward = await maybe_await(
    self.reward_service.select_reward(
        total_weight=total_weight,
        user_id=user.id,
        exclude_reward_ids=[]  # Or remove this parameter entirely if not needed
    )
)
```

**Note**: We can keep the `exclude_reward_ids` parameter for other use cases (like testing or manual exclusions), but it's no longer populated from `get_todays_awarded_rewards()`.

### Phase 4: Admin Interface Updates

#### 4.1 Update Django Admin for Reward Model

**File**: `src/core/admin.py`

**Changes needed**:
- Add `max_daily_claims` to the list_display (if present)
- Add `max_daily_claims` to any fieldsets for Reward editing
- Add help text to make it clear: "0 or NULL = unlimited, 1 = once per day, etc."

### Phase 5: Bot Interface Updates (Optional)

#### 5.1 Update Add Reward Conversation Handler

**File**: `src/bot/handlers/reward_handlers.py`

**Optional enhancement**: When creating a new reward via bot commands, add a step to ask for `max_daily_claims` value.

**Current flow** (around line 48-57):
- AWAITING_REWARD_NAME
- AWAITING_REWARD_TYPE
- AWAITING_REWARD_WEIGHT
- AWAITING_REWARD_PIECES
- AWAITING_REWARD_VALUE
- AWAITING_REWARD_CONFIRM

**New flow** (optional):
- Add AWAITING_REWARD_DAILY_LIMIT state
- Add keyboard builder `build_reward_daily_limit_keyboard()` in `src/bot/keyboards.py`
- Add message constants to `src/bot/messages.py`

**Decision**: This is OPTIONAL for MVP. Admins can set `max_daily_claims` via Django admin. Bot creation can default to `NULL` (unlimited).

## Algorithm: Enhanced Reward Selection with Daily Limits

**Location**: `src/services/reward_service.py:54-118`

### Step-by-step logic for modified select_reward():

1. **Fetch all active rewards** from database
   - If none exist, return default "No reward" object

2. **Apply exclude_reward_ids filter** (backwards compatibility)
   - Remove any rewards in the exclusion list

3. **Apply user-specific filters** (if user_id provided):

   a. **Fetch user's reward progress**
      - `progress_list = await self.progress_repo.get_all_by_user(user_id)`
      - Create a dict: `progress_by_reward_id = {p.reward_id: p for p in progress_list}`

   b. **For each reward in rewards list**:
      - Get progress: `progress = progress_by_reward_id.get(reward.id)`

      - **Filter 1: Completion check**
        - If progress exists and `progress.pieces_earned >= reward.pieces_required`:
          - Exclude this reward
          - Log: "Excluding {reward.name} - already completed"
          - Continue to next reward

      - **Filter 2: Daily limit check**
        - If `reward.max_daily_claims` is not NULL and not 0:
          - Count today's unclaimed pieces: `today_count = await self.get_todays_pieces_by_reward(user_id, reward.id)`
          - If `today_count >= reward.max_daily_claims`:
            - Exclude this reward
            - Log: "Excluding {reward.name} - daily limit reached ({today_count}/{reward.max_daily_claims})"
            - Continue to next reward

      - If reward passes both filters, keep it in the eligible list

4. **Check if any rewards remain**
   - If eligible list is empty, return default "No reward" object
   - Log: "No eligible rewards remain after filtering"

5. **Perform weighted random selection**
   - Calculate adjusted_weights: `[reward.weight * total_weight for reward in eligible_rewards]`
   - Select: `selected = random.choices(eligible_rewards, weights=adjusted_weights, k=1)[0]`

6. **Return selected reward**
   - Log: "Selected reward: {reward.name}"

### Edge Cases:
- `user_id=None`: Skip all user-specific filtering (backwards compatible)
- `max_daily_claims=NULL` or `0`: Skip daily limit check for that reward (unlimited)
- No progress record for a reward: Treat as 0 pieces earned (eligible)
- All rewards excluded: Return "No reward" object

## Algorithm: Count Today's Unclaimed Pieces

**Location**: `src/services/reward_service.py` (new function)

### Step-by-step logic for get_todays_pieces_by_reward():

1. **Get today's habit logs for this user/reward**
   - Query: `habit_log_repository.get_todays_logs_by_user(user_id)`
   - Filter where `reward_id == reward_id` and `got_reward == True`
   - Count = number of matching logs

2. **Get current reward progress**
   - `progress = await self.progress_repo.get_by_user_and_reward(user_id, reward_id)`

3. **Check if reward is claimed**
   - If `progress` is None: return 0 (no pieces yet)
   - If `progress.get_status() == CLAIMED`: return 0 (claimed pieces don't count)
   - Otherwise: return count from step 1

4. **Return the count**

## Files to Modify

### Database Layer
1. **New migration file**: `src/core/migrations/XXXX_add_reward_daily_limits.py`
   - Add `max_daily_claims` field to Reward model

2. **src/core/models.py:112-162** (Reward model)
   - Add `max_daily_claims` field definition

3. **src/models/reward.py** (Pydantic model)
   - Add `max_daily_claims: int | None = None` field

### Service Layer
4. **src/services/reward_service.py:54-118** (select_reward function)
   - Implement completion check
   - Implement daily limit check with per-reward max_daily_claims
   - Add detailed logging for exclusions

5. **src/services/reward_service.py** (new function ~line 145)
   - Add `get_todays_pieces_by_reward()` helper function

6. **src/services/reward_service.py:211-242** (mark_reward_claimed function)
   - Add `pieces_earned=0` to the update

7. **src/services/habit_service.py:169-183**
   - Simplify to not pass exclusion list from `get_todays_awarded_rewards()`

### Admin Layer
8. **src/core/admin.py**
   - Add `max_daily_claims` to Reward admin interface

### Repository Layer (Verification)
9. **src/core/repositories.py**
   - Verify `get_todays_logs_by_user()` exists and works correctly
   - May need to add filtering capability if not present

### Testing Layer
10. **tests/test_reward_service.py**
    - Test `get_todays_pieces_by_reward()` counts correctly
    - Test `select_reward()` excludes rewards at daily limit
    - Test `select_reward()` allows unlimited rewards (max_daily_claims=NULL/0)
    - Test `mark_reward_claimed()` resets pieces_earned to 0
    - Test claimed rewards don't count toward daily limit

11. **tests/test_habit_service.py**
    - Integration test: Log habit multiple times, verify limited rewards stop appearing
    - Integration test: Claim reward, verify it can be earned again if limit allows
    - Integration test: Unlimited reward can be earned multiple times same day

## Implementation Notes

- **Database migration required** - add `max_daily_claims` to Reward model
- **Default value for existing rewards**: Migration should set `max_daily_claims=NULL` (unlimited) for all existing rewards to maintain current behavior
- **Backwards compatible**: Code gracefully handles NULL/0 as unlimited
- **Performance consideration**: `get_todays_pieces_by_reward()` queries habit_logs per reward - consider caching today's logs if performance becomes an issue
- All user-facing messages should use message constants from `src/bot/messages.py`
- Follow HTML formatting rules from RULES.md for any new messages
- **Critical**: The counting logic only counts UNCLAIMED pieces from today, so claiming a reward "frees up" that slot in the daily limit
