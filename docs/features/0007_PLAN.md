# Feature 0007: Habit Management Commands

## Description

Add three new bot commands for user habit management: `/add_habit` (or `/new_habit`), `/remove_habit`, and `/edit_habit`. These commands allow users to create, deactivate, and modify their habits through sequential button-based prompts, following the established conversation handler pattern.

**Key requirements from user**:
- Sequential prompts with buttons for field collection
- All fields collected: name, weight (1-100), category (predefined list)
- Soft delete (set `active=false`) for removal
- Sequential re-entry flow for editing with current values displayed
- Predefined category list with buttons

## Files to Modify

### New Files

**src/bot/handlers/habit_management_handler.py** (create new):
- Three conversation handlers: `add_habit_conversation`, `edit_habit_conversation`, `remove_habit_conversation`
- `/add_habit` flow (4 states): Entry ‚Üí Name input ‚Üí Weight selection ‚Üí Category selection ‚Üí Confirm & Save
- `/edit_habit` flow (5 states): Entry ‚Üí Habit selection ‚Üí Name input ‚Üí Weight selection ‚Üí Category selection ‚Üí Confirm & Save
- `/remove_habit` flow (2 states): Entry ‚Üí Habit selection ‚Üí Confirm & Deactivate

**src/bot/keyboards.py** (modify existing):
- `build_weight_selection_keyboard()` - Show weight ranges as buttons (1-10, 11-20, etc.) or direct numeric buttons
- `build_category_selection_keyboard()` - Show predefined categories (Health, Productivity, Social, Learning, etc.)
- `build_habits_for_edit_keyboard()` - Show user's active habits for selection in edit/remove flows
- `build_habit_confirmation_keyboard()` - Yes/No confirmation buttons

**src/bot/messages.py** (modify existing):
- Add constants for habit management prompts, errors, and success messages in all languages (en, ru, kk):
  - `HELP_ADD_HABIT_NAME_PROMPT` - "Please enter the name for your new habit:"
  - `HELP_ADD_HABIT_WEIGHT_PROMPT` - "Select the weight for this habit (1-100). Weight affects reward chances:"
  - `HELP_ADD_HABIT_CATEGORY_PROMPT` - "Select a category for this habit:"
  - `HELP_ADD_HABIT_CONFIRM` - "Review your new habit:\n<b>Name:</b> {name}\n<b>Weight:</b> {weight}\n<b>Category:</b> {category}\n\nCreate this habit?"
  - `SUCCESS_HABIT_CREATED` - "‚úÖ Habit '<b>{name}</b>' created successfully!"
  - `ERROR_HABIT_NAME_TOO_LONG` - "‚ùå Habit name is too long (max 100 characters)."
  - `ERROR_HABIT_NAME_EMPTY` - "‚ùå Habit name cannot be empty."
  - `ERROR_WEIGHT_INVALID` - "‚ùå Invalid weight. Please select a value between 1-100."
  - `HELP_EDIT_HABIT_SELECT` - "Select a habit to edit:"
  - `HELP_EDIT_HABIT_NAME_PROMPT` - "Current name: <b>{current_name}</b>\n\nEnter new name:"
  - `HELP_EDIT_HABIT_WEIGHT_PROMPT` - "Current weight: <b>{current_weight}</b>\n\nSelect new weight:"
  - `HELP_EDIT_HABIT_CATEGORY_PROMPT` - "Current category: <b>{current_category}</b>\n\nSelect new category:"
  - `HELP_EDIT_HABIT_CONFIRM` - "Review changes:\n<b>Name:</b> {old_name} ‚Üí {new_name}\n<b>Weight:</b> {old_weight} ‚Üí {new_weight}\n<b>Category:</b> {old_category} ‚Üí {new_category}\n\nSave changes?"
  - `SUCCESS_HABIT_UPDATED` - "‚úÖ Habit '<b>{name}</b>' updated successfully!"
  - `HELP_REMOVE_HABIT_SELECT` - "Select a habit to remove:"
  - `HELP_REMOVE_HABIT_CONFIRM` - "Are you sure you want to remove '<b>{name}</b>'?\n\n‚ö†Ô∏è This will deactivate the habit. Your history will be preserved."
  - `SUCCESS_HABIT_REMOVED` - "‚úÖ Habit '<b>{name}</b>' removed successfully."
  - `ERROR_NO_HABITS_TO_EDIT` - "‚ùå You don't have any habits to edit."
  - `ERROR_NO_HABITS_TO_REMOVE` - "‚ùå You don't have any habits to remove."
  - `INFO_HABIT_CANCEL` - "‚ùå Habit operation cancelled."

### Existing Files to Modify

**src/bot/main.py**:
- Line ~132: Register three new conversation handlers:
  ```python
  from src.bot.handlers.habit_management_handler import (
      add_habit_conversation,
      edit_habit_conversation,
      remove_habit_conversation
  )

  application.add_handler(add_habit_conversation)
  application.add_handler(edit_habit_conversation)
  application.add_handler(remove_habit_conversation)
  ```

**src/airtable/repositories.py** (HabitRepository):
- Add method `create(habit: Habit) -> Habit` (lines ~90): Create new habit in Airtable
- Add method `update(habit_id: str, updates: dict) -> Habit` (lines ~95): Update existing habit fields
- Add method `soft_delete(habit_id: str) -> Habit` (lines ~100): Set `active=false`
- Add method `get_active_habits_by_user(user_id: str) -> list[Habit]` (lines ~105): For edit/remove selection (if not already exists)

**src/bot/messages.py** (help text):
- Update `HELP_START_MESSAGE` constant: Add descriptions for `/add_habit`, `/edit_habit`, `/remove_habit` commands in all languages

## Implementation Details

### /add_habit Flow (ConversationHandler)

**States**:
1. `AWAITING_HABIT_NAME` - User types habit name
2. `AWAITING_HABIT_WEIGHT` - User clicks weight button (1-100 range buttons)
3. `AWAITING_HABIT_CATEGORY` - User clicks category button
4. `AWAITING_HABIT_CONFIRMATION` - User clicks Yes/No to confirm

**Conversation Definition**:
```python
add_habit_conversation = ConversationHandler(
    entry_points=[CommandHandler("add_habit", add_habit_command), CommandHandler("new_habit", add_habit_command)],
    states={
        AWAITING_HABIT_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, habit_name_received)
        ],
        AWAITING_HABIT_WEIGHT: [
            CallbackQueryHandler(habit_weight_selected, pattern="^weight_")
        ],
        AWAITING_HABIT_CATEGORY: [
            CallbackQueryHandler(habit_category_selected, pattern="^category_")
        ],
        AWAITING_HABIT_CONFIRMATION: [
            CallbackQueryHandler(habit_confirmed, pattern="^confirm_(yes|no)$")
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel_add_habit)]
)
```

**Context Storage**: Use `context.user_data` to store:
- `habit_name: str`
- `habit_weight: int`
- `habit_category: str`

**Handler Functions**:
- `add_habit_command()` - Entry point, prompt for name
- `habit_name_received()` - Validate name (not empty, max 100 chars), store in context, show weight keyboard
- `habit_weight_selected()` - Extract weight from callback_data, store in context, show category keyboard
- `habit_category_selected()` - Extract category, store in context, show confirmation message with summary
- `habit_confirmed()` - If "yes": create habit via repository, send success message; If "no": cancel
- `cancel_add_habit()` - Clear context, send cancellation message

**Callback Data Patterns**:
- Weight: `weight_10`, `weight_20`, ..., `weight_100` (or ranges: `weight_1-10`, `weight_11-20`)
- Category: `category_health`, `category_productivity`, `category_social`, `category_learning`
- Confirm: `confirm_yes`, `confirm_no`

**Predefined Categories** (in config.py or constants):
```python
HABIT_CATEGORIES = [
    "Health",       # üèÉ Health
    "Productivity", # üíº Productivity
    "Social",       # üë• Social
    "Learning",     # üìö Learning
    "Fitness",      # üí™ Fitness
    "Mindfulness"   # üßò Mindfulness
]
```

### /edit_habit Flow (ConversationHandler)

**States**:
1. `AWAITING_HABIT_SELECTION` - User clicks habit button to select which to edit
2. `AWAITING_EDIT_NAME` - User types new name
3. `AWAITING_EDIT_WEIGHT` - User clicks new weight button
4. `AWAITING_EDIT_CATEGORY` - User clicks new category button
5. `AWAITING_EDIT_CONFIRMATION` - User confirms changes

**Conversation Definition**:
```python
edit_habit_conversation = ConversationHandler(
    entry_points=[CommandHandler("edit_habit", edit_habit_command)],
    states={
        AWAITING_HABIT_SELECTION: [
            CallbackQueryHandler(habit_edit_selected, pattern="^edit_habit_")
        ],
        AWAITING_EDIT_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, habit_edit_name_received)
        ],
        AWAITING_EDIT_WEIGHT: [
            CallbackQueryHandler(habit_edit_weight_selected, pattern="^weight_")
        ],
        AWAITING_EDIT_CATEGORY: [
            CallbackQueryHandler(habit_edit_category_selected, pattern="^category_")
        ],
        AWAITING_EDIT_CONFIRMATION: [
            CallbackQueryHandler(habit_edit_confirmed, pattern="^confirm_(yes|no)$")
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel_edit_habit)]
)
```

**Context Storage**: Use `context.user_data` to store:
- `editing_habit_id: str` - Airtable ID of habit being edited
- `old_habit_name: str`, `old_habit_weight: int`, `old_habit_category: str` - Original values for comparison
- `new_habit_name: str`, `new_habit_weight: int`, `new_habit_category: str` - New values

**Handler Functions**:
- `edit_habit_command()` - Entry, get user's active habits, show selection keyboard or error if none
- `habit_edit_selected()` - Load habit from DB, store old values and habit_id in context, prompt for new name
- `habit_edit_name_received()` - Validate and store new name, show weight keyboard with current value highlighted
- `habit_edit_weight_selected()` - Store new weight, show category keyboard with current value highlighted
- `habit_edit_category_selected()` - Store new category, show confirmation with before/after comparison
- `habit_edit_confirmed()` - If "yes": update habit via repository.update(), send success; If "no": cancel
- `cancel_edit_habit()` - Clear context, send cancellation

**Callback Data Pattern**:
- Habit selection: `edit_habit_<habit_id>` (e.g., `edit_habit_rec123ABC`)

### /remove_habit Flow (ConversationHandler)

**States**:
1. `AWAITING_REMOVE_SELECTION` - User clicks habit button to select which to remove
2. `AWAITING_REMOVE_CONFIRMATION` - User confirms removal

**Conversation Definition**:
```python
remove_habit_conversation = ConversationHandler(
    entry_points=[CommandHandler("remove_habit", remove_habit_command)],
    states={
        AWAITING_REMOVE_SELECTION: [
            CallbackQueryHandler(habit_remove_selected, pattern="^remove_habit_")
        ],
        AWAITING_REMOVE_CONFIRMATION: [
            CallbackQueryHandler(habit_remove_confirmed, pattern="^confirm_(yes|no)$")
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel_remove_habit)]
)
```

**Context Storage**:
- `removing_habit_id: str`
- `removing_habit_name: str`

**Handler Functions**:
- `remove_habit_command()` - Entry, get user's active habits, show selection keyboard or error
- `habit_remove_selected()` - Store habit_id and name in context, show confirmation warning
- `habit_remove_confirmed()` - If "yes": call repository.soft_delete(), send success; If "no": cancel
- `cancel_remove_habit()` - Clear context, send cancellation

**Callback Data Pattern**:
- Habit selection: `remove_habit_<habit_id>`

### Repository Methods (src/airtable/repositories.py)

**HabitRepository.create(habit: Habit) -> Habit**:
```python
def create(self, habit: Habit) -> Habit:
    """Create new habit in Airtable."""
    data = {
        "name": habit.name,
        "weight": habit.weight,
        "category": habit.category,
        "active": habit.active
    }
    record = self.table.create(data)
    return self._record_to_habit(record)
```

**HabitRepository.update(habit_id: str, updates: dict) -> Habit**:
```python
def update(self, habit_id: str, updates: dict) -> Habit:
    """Update habit fields in Airtable.

    Args:
        habit_id: Airtable record ID
        updates: Dict with fields to update (name, weight, category, active)
    """
    record = self.table.update(habit_id, updates)
    return self._record_to_habit(record)
```

**HabitRepository.soft_delete(habit_id: str) -> Habit**:
```python
def soft_delete(self, habit_id: str) -> Habit:
    """Soft delete habit by setting active=false."""
    return self.update(habit_id, {"active": False})
```

**HabitRepository.get_active_habits_by_user(user_id: str) -> list[Habit]** (if not exists):
```python
def get_active_habits_by_user(self, user_id: str) -> list[Habit]:
    """Get all active habits (for habit selection in edit/remove)."""
    # Note: Habits table doesn't have user_id field (habits are global)
    # This method should return all active habits
    return self.get_all_active()
```

### Keyboard Builders (src/bot/keyboards.py)

**build_weight_selection_keyboard(current_weight: int | None = None, language: str = 'en') -> InlineKeyboardMarkup**:
- Show buttons for weight ranges or individual values
- Option 1 (ranges): "1-10", "11-20", "21-30", ..., "91-100" (10 buttons)
- Option 2 (individuals): "10", "20", "30", ..., "100" (10 buttons)
- Highlight current_weight if editing (add ‚úì emoji to button text)

**build_category_selection_keyboard(current_category: str | None = None, language: str = 'en') -> InlineKeyboardMarkup**:
- Show predefined category buttons with emojis:
  - üèÉ Health
  - üíº Productivity
  - üë• Social
  - üìö Learning
  - üí™ Fitness
  - üßò Mindfulness
- Highlight current_category if editing

**build_habits_for_edit_keyboard(habits: list[Habit], operation: str) -> InlineKeyboardMarkup**:
- Show habit buttons with callback_data based on operation
- `operation="edit"` ‚Üí `edit_habit_<habit_id>`
- `operation="remove"` ‚Üí `remove_habit_<habit_id>`
- Display format: "{habit.name} ({habit.category})"

**build_habit_confirmation_keyboard(language: str = 'en') -> InlineKeyboardMarkup**:
- Two buttons: "‚úÖ Yes" (confirm_yes), "‚ùå No" (confirm_no)

### Error Handling & Validation

**Name Validation**:
- Not empty: `if not habit_name.strip():`
- Max length: `if len(habit_name) > 100:`
- Duplicate check optional: Check if habit with same name already exists (warning but allow)

**Weight Validation**:
- Must be integer 1-100
- Callback data parsing: `int(query.data.replace("weight_", ""))`

**User Validation** (all handlers):
- Follow standard pattern from RULES.md:
  ```python
  telegram_id = str(update.effective_user.id)
  user = user_repository.get_by_telegram_id(telegram_id)
  if not user:
      await update.message.reply_text(msg('ERROR_USER_NOT_FOUND', lang))
      return
  if not user.active:
      await update.message.reply_text(msg('ERROR_USER_INACTIVE', lang))
      return
  ```

**Empty Habit List**:
- In `/edit_habit` and `/remove_habit`, check if user has any active habits
- If empty, send error message and return ConversationHandler.END

### Logging Pattern

Follow RULES.md logging pattern for all handlers:

```python
logger.info(f"üì® Received /add_habit from user {telegram_id} (@{username})")
logger.info(f"üìù User {telegram_id} entered habit name: '{habit_name}'")
logger.info(f"üéØ User {telegram_id} selected weight: {weight}")
logger.info(f"üéØ User {telegram_id} selected category: {category}")
logger.info(f"‚úÖ Created habit '{habit_name}' for user {telegram_id}")
logger.info(f"üì§ Sent success message to {telegram_id}")
```

Use emojis:
- üì® - Incoming command
- üìù - Text input received
- üéØ - Button selection
- ‚úÖ - Success
- ‚ùå - Error/cancellation
- üì§ - Outgoing message

### Testing Considerations

**Manual Testing Checklist**:
1. `/add_habit` - Happy path: Create habit with all fields
2. `/add_habit` - Empty name validation
3. `/add_habit` - Name too long (>100 chars)
4. `/add_habit` - Cancel midway with `/cancel`
5. `/edit_habit` - No habits available
6. `/edit_habit` - Happy path: Edit all fields
7. `/edit_habit` - Cancel during editing
8. `/remove_habit` - No habits available
9. `/remove_habit` - Happy path: Soft delete
10. `/remove_habit` - Cancel confirmation
11. All commands - User not found
12. All commands - User inactive
13. Multi-lingual - Test all messages in en/ru/kk

**Unit Tests** (create test_habit_management_handler.py):
- Mock user_repository, habit_repository
- Test each conversation state transition
- Test validation logic (name, weight)
- Test context storage and retrieval
- Test cancel handlers

### Multi-lingual Support

All message constants must be added to `src/bot/messages.py` with translations in `_TRANSLATIONS` dict for:
- `ru` - Russian
- `kk` - Kazakh

Use `msg()` function in all handlers:
```python
lang = get_message_language(telegram_id, update)
await update.message.reply_text(msg('HELP_ADD_HABIT_NAME_PROMPT', lang))
```

### Configuration Constants

Add to `src/config.py` (or create constants file):
```python
# Predefined habit categories with emojis
HABIT_CATEGORIES = [
    ("health", "üèÉ Health"),
    ("productivity", "üíº Productivity"),
    ("social", "üë• Social"),
    ("learning", "üìö Learning"),
    ("fitness", "üí™ Fitness"),
    ("mindfulness", "üßò Mindfulness")
]

# Habit validation limits
HABIT_NAME_MAX_LENGTH = 100
HABIT_WEIGHT_MIN = 1
HABIT_WEIGHT_MAX = 100
```

## Implementation Notes

1. **Context Cleanup**: Always clear `context.user_data` in cancel handlers and at end of conversation
2. **Callback Query Answering**: Always call `await query.answer()` after handling CallbackQueryHandler to remove loading state
3. **Message Editing**: Use `query.edit_message_text()` for button callbacks instead of sending new messages
4. **HTML Formatting**: All messages use `parse_mode="HTML"` as per RULES.md
5. **Airtable IDs**: Use Airtable record IDs (not user-facing IDs) for habit_id in callback_data
6. **Weight Input**: Consider using numeric range buttons (1-10, 11-20, etc.) for better UX instead of 100 individual buttons
7. **Category Extension**: If predefined list doesn't cover user needs, can add "Other" category or allow custom text in future iteration
8. **Soft Delete**: Removed habits (active=false) won't appear in habit selection for `/habit_done` (repository already filters by active=True)

## Django Migration Compatibility

This feature follows Django-compatible patterns:
- Business logic in service layer (minimal - validation in handlers is acceptable for this feature)
- Data access through repository pattern (HabitRepository)
- Model-based approach (Habit model with Pydantic)
- Centralized configuration (HABIT_CATEGORIES constant)
- Multi-lingual support structure compatible with Django i18n
