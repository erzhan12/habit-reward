# Feature 0027: Remove `RewardType.NONE`, keep “no reward” at 50% probability

## Overview

The user requirement is:
- “I will remove reward type None because now it has constant weight.”
- “No reward should have weight 1 * sum(other reward weights) 50% probability. doesn't depend on streak multiplier.”
- “so befre reward calculation app will add none reward authomatically with weight equal total weight of other rewards.”

This plan removes the user-facing/persisted `none` reward type and keeps the “no reward” outcome as an **implicit** option during reward selection, with its weight derived from other rewards (50% of their summed weight).

## Current State (relevant)

- Reward types include `virtual`, `real`, and `none`:
  - Pydantic model enum: `src/models/reward.py` (`RewardType.NONE`)
  - Django model choices: `src/core/models.py` (`Reward.RewardType.NONE`)
  - API validation accepts `none`: `src/api/v1/routers/rewards.py` (`pattern="^(virtual|real|none)$"`)
  - Bot creation/edit flows expose “None” type:
    - `src/bot/keyboards.py` (`build_reward_type_keyboard`, `build_reward_edit_type_keyboard`)
    - `src/bot/handlers/reward_handlers.py` (type label/summary maps)
    - `src/bot/messages.py` (`BUTTON_REWARD_TYPE_NONE` translations)
- Reward selection happens in `src/services/reward_service.py:RewardService.select_reward()` via `random.choices`.
- “No reward” is currently represented by a `RewardType.NONE` reward object in some paths (e.g., fallbacks), and habit completion treats `RewardType.NONE` as `got_reward=False` in `src/services/habit_service.py`.

## Proposed Changes

### 1) Replace persisted `none` reward type with an implicit “no reward” outcome

Core behavioral goal: users should not create/manage a `none` reward definition, but “no reward” should remain possible during selection with weight equal to **50% of the sum of all rewards**.

Implementation approach:
- Make `RewardService.select_reward(...)` select between:
  - the eligible, active rewards (types `virtual`/`real`)
  - an implicit “no reward” option (represented as `None` rather than a `RewardType.NONE` reward)

Files/functions:
- `src/services/reward_service.py`
  - Update `RewardService.select_reward()` to:
    1. Load active rewards for `user_id`
    2. Apply existing filters (excluded IDs, completed rewards, daily limits)
    3. Exclude any persisted `type == "none"` reward records as a safety net during transition
    4. Compute selection weights for all remaining rewards
    5. Compute “no reward” weight as `1.0 * sum(other_weights)` so “no reward” has 50% probability
    6. Run weighted selection across `(rewards + [None])`
    7. Return `Reward | None`

### 2) Remove `none` from user-facing reward CRUD (bot + API)

Bot/UI:
- `src/bot/keyboards.py`
  - Remove the “None” option from `build_reward_type_keyboard(...)`
  - Remove the “None” option from `build_reward_edit_type_keyboard(...)`
- `src/bot/handlers/reward_handlers.py`
  - Remove `RewardType.NONE` mappings in `_reward_type_label(...)` and `_format_reward_summary(...)`
  - Ensure handlers that parse callbacks don’t accept `reward_type_none` / `edit_reward_type_none`
- `src/bot/messages.py`
  - Remove or deprecate `BUTTON_REWARD_TYPE_NONE` keys in all supported languages (depending on whether you want to keep them for historical/backward compatibility)
- `src/bot/formatters.py`
  - Remove `RewardType.NONE` emoji mapping in reward list formatting (since rewards shown to users should no longer be `none`-typed)

API:
- `src/api/v1/routers/rewards.py`
  - Change request validation regexes to allow only `virtual|real`
  - Ensure update logic rejects attempts to set type to `none`

### 3) Remove `RewardType.NONE` from shared types (data layer)

- `src/models/reward.py`
  - Remove `RewardType.NONE` from the enum
- `src/core/models.py`
  - Remove `Reward.RewardType.NONE` from Django `TextChoices`

If existing persisted rewards have `type="none"`, decide (see “Open Questions”) whether to:
- deactivate them (confirmed requirement).

### 4) Update habit completion logic to use `Reward | None` instead of `RewardType.NONE`

- `src/services/habit_service.py`
  - Replace `got_reward = selected_reward.type != RewardType.NONE` with `got_reward = selected_reward is not None`
  - Ensure:
    - `reward_id` is only written when `got_reward=True`
    - progress is only updated when `got_reward=True`
    - audit snapshot uses `selected_reward.name` only when `selected_reward` is not `None`

Also update any “none” terminology in comments/docs:
- `src/models/habit_log.py` (comment: “no reward or ‘none’ type reward”)
- `src/bot/formatters.py` (comment: “no reward or ‘none’ type reward”)

### 5) Airtable compatibility (if still used)

If Airtable repositories are still exercised in development/tests:
- `src/airtable/repositories.py:_record_to_reward()`
- `src/airtable/reward_repository.py:_record_to_reward()`

Adjust default type parsing to avoid defaulting to `"none"` and define behavior when legacy rows contain `"none"` (e.g., map to `"real"` temporarily, or treat as invalid/excluded).

## Reward Selection Algorithm (step-by-step)

Inside `RewardService.select_reward(total_weight, user_id, exclude_reward_ids)`:
1. Fetch all active rewards for `user_id`.
2. Remove excluded rewards by ID (existing behavior).
3. Apply eligibility filters (existing behavior):
   - filter out completed rewards (`pieces_earned >= pieces_required`)
   - filter out rewards that hit `max_daily_claims`
4. Treat any persisted `type == "none"` reward as ineligible (transition guard).
5. If no eligible rewards remain: return `None` (“no reward”).
6. Compute `reward_weights` for eligible rewards:
   - Use the same base as today (currently `reward.weight * total_weight`).
7. Compute implicit “no reward” weight:
   - `no_reward_weight = 1.0 * sum(reward_weights)`
   - This yields `P(no_reward) = sum(reward_weights) / (sum(reward_weights) + sum(reward_weights)) = 0.5`.
   - Because `reward_weights` are uniformly scaled by `total_weight`, the 50% probability does not depend on the streak multiplier.
8. Use `random.choices` to choose one item from `[eligible_rewards..., None]` with weights `[reward_weights..., no_reward_weight]`.
9. Return the selected `Reward` or `None`.

## Unit Tests

Update and add tests to reflect removal of `RewardType.NONE` and the new implicit “no reward” weighting.

Reward selection tests (`tests/test_reward_service.py`):
- Selecting from multiple rewards:
  - Patch `random.choices` and assert the weights include a final “no reward” weight equal to `0.5 * sum(reward_weights)`.
  - Verify the population passed to `random.choices` includes a `None` sentinel.
- No rewards exist / all rewards filtered out:
  - `select_reward(...)` returns `None`.
- Legacy persisted `type="none"` rewards:
  - If present in repo results, they are excluded from eligible rewards and do not contribute to `sum(reward_weights)`.

Habit completion integration tests (`tests/test_habit_service.py` and any relevant bot handler tests):
- When `select_reward` returns `None`:
  - `got_reward=False`
  - `reward_id` is `None` in the created habit log
  - reward progress is not updated
- When `select_reward` returns a reward:
  - `got_reward=True` and progress is updated as before

API validation tests (`tests/api/test_rewards.py`):
- Creating/updating a reward with `type="none"` returns a validation error (status code depends on the current error mapping).
- Creating/updating with `type="virtual"` and `type="real"` continues to succeed.

Bot flow tests (where applicable, e.g. `tests/test_bot_handlers.py`):
- Reward creation/edit keyboards no longer include the “None” type option.

## Confirmed Requirements

- “No reward” probability is 50% by setting `no_reward_weight = 1 * sum(other reward weights)`.
- The 50% reward-vs-no-reward split must not depend on the streak multiplier.
- Existing persisted rewards with `type="none"` should be deactivated.
- It is OK to remove `none` from API validation (only `virtual|real` allowed).
