# Feature 0009: Django Architecture Migration with Webhooks

## Overview

Migrate the habit reward bot from Airtable-based architecture to Django framework with SQLite (development) and PostgreSQL (production). Replace Telegram polling with webhooks for improved scalability and resource efficiency.

## Current Architecture

**Database**: Airtable cloud (5 tables via `pyairtable`)
- `src/airtable/client.py` - Singleton API wrapper
- `src/airtable/repositories.py` - 5 repository classes (User, Habit, HabitLog, Reward, RewardProgress)

**Telegram Bot**: Polling mode
- `src/bot/main.py:163` - `application.run_polling(allowed_updates=Update.ALL_TYPES)`
- 8 handler modules in `src/bot/handlers/`
- Async handlers using `python-telegram-bot` Application class

**Models**: Pydantic v2 models
- `src/models/` - 5 core models with validators

**Services**: Framework-agnostic business logic (no changes needed)
- `src/services/` - 4 service modules (habit, streak, reward, nlp)

**Configuration**: pydantic-settings
- `src/config.py` - Settings class loading from `.env`

## Phase 1: Data Layer Migration

### 1.1 Django Project Setup

**Create Django project structure:**
```
src/
‚îú‚îÄ‚îÄ habit_reward_project/          # Django project root
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ settings.py                # Django settings (replaces src/config.py)
‚îÇ   ‚îú‚îÄ‚îÄ urls.py                    # URL routing
‚îÇ   ‚îú‚îÄ‚îÄ wsgi.py                    # WSGI entry point
‚îÇ   ‚îî‚îÄ‚îÄ asgi.py                    # ASGI entry point (for webhooks)
‚îú‚îÄ‚îÄ core/                          # Django app for core models
‚îÇ   ‚îú‚îÄ‚îÄ models.py                  # Django models (replaces src/models/)
‚îÇ   ‚îú‚îÄ‚îÄ managers.py                # Custom QuerySet managers
‚îÇ   ‚îú‚îÄ‚îÄ admin.py                   # Django admin config
‚îÇ   ‚îî‚îÄ‚îÄ migrations/                # Database migrations
‚îî‚îÄ‚îÄ manage.py                      # Django management CLI
```

**Dependencies to add** (update `pyproject.toml`):
```toml
django = ">=5.0"
psycopg2-binary = ">=2.9"  # PostgreSQL adapter
dj-database-url = ">=2.1"  # Database URL parsing
django-environ = ">=0.11"  # Environment variable management
```

**Dependencies to remove**:
```toml
pyairtable = ">=2.2.0"     # No longer needed
pydantic-settings = "..."  # Replaced by django-environ
```

### 1.2 Django Models (replaces `src/models/` and `src/airtable/repositories.py`)

**File**: `src/core/models.py`

Convert Pydantic models to Django models:

#### User Model
```python
from django.db import models

class User(models.Model):
    """User account and profile."""
    telegram_id = models.CharField(max_length=50, unique=True, db_index=True)
    name = models.CharField(max_length=255)
    active = models.BooleanField(default=False)
    language = models.CharField(max_length=2, default='en', choices=[
        ('en', 'English'),
        ('ru', 'Russian'),
        ('kk', 'Kazakh'),
    ])
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'users'
        indexes = [models.Index(fields=['telegram_id'])]

    def __str__(self):
        return f"{self.name} ({self.telegram_id})"
```

**Mapping from Pydantic**:
- `id: str | None` ‚Üí Auto-generated `id` primary key (Django default)
- `telegram_id: str` ‚Üí `CharField(unique=True, db_index=True)` for fast lookups
- `active: bool = False` ‚Üí `BooleanField(default=False)` - security by default
- Add timestamps: `created_at`, `updated_at` (best practice)

#### Habit Model
```python
class Habit(models.Model):
    """Habit definition."""
    name = models.CharField(max_length=255, unique=True)
    weight = models.IntegerField(default=10, validators=[MinValueValidator(1), MaxValueValidator(100)])
    category = models.CharField(max_length=100, null=True, blank=True)
    active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'habits'
        indexes = [models.Index(fields=['active', 'name'])]

    def __str__(self):
        return self.name
```

**Mapping**:
- `weight: int = 10` ‚Üí `IntegerField` with validators (1-100 range)
- `active: bool = True` ‚Üí Soft delete support
- Add index on `(active, name)` for filtering active habits

#### Reward Model
```python
class Reward(models.Model):
    """Reward definition."""
    class RewardType(models.TextChoices):
        VIRTUAL = 'VIRTUAL', 'Virtual'
        REAL = 'REAL', 'Real'
        NONE = 'NONE', 'None'

    name = models.CharField(max_length=255, unique=True)
    weight = models.FloatField(default=1.0)
    type = models.CharField(max_length=10, choices=RewardType.choices, default=RewardType.VIRTUAL)
    pieces_required = models.IntegerField(default=1, validators=[MinValueValidator(1)])
    piece_value = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'rewards'

    def __str__(self):
        return self.name
```

**Mapping**:
- `type: RewardType` ‚Üí Django `TextChoices` enum
- `piece_value: float | None` ‚Üí `DecimalField` (better for monetary values)
- `pieces_required: int = 1` ‚Üí All rewards are cumulative (unified system)

#### RewardProgress Model
```python
class RewardProgress(models.Model):
    """User progress toward a reward."""
    class RewardStatus(models.TextChoices):
        PENDING = 'PENDING', 'Pending'
        ACHIEVED = 'ACHIEVED', 'Achieved'
        CLAIMED = 'CLAIMED', 'Claimed'

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='reward_progress')
    reward = models.ForeignKey(Reward, on_delete=models.CASCADE, related_name='user_progress')
    pieces_earned = models.IntegerField(default=0)
    claimed = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'reward_progress'
        unique_together = [('user', 'reward')]
        indexes = [
            models.Index(fields=['user', 'reward']),
            models.Index(fields=['user']),
        ]

    @property
    def status(self):
        """Computed status (replaces Airtable formula)."""
        if self.claimed:
            return self.RewardStatus.CLAIMED
        elif self.pieces_earned >= self.reward.pieces_required:
            return self.RewardStatus.ACHIEVED
        else:
            return self.RewardStatus.PENDING

    @property
    def pieces_required(self):
        """Cached from linked reward (replaces Airtable lookup)."""
        return self.reward.pieces_required

    def __str__(self):
        return f"{self.user.name} - {self.reward.name} ({self.pieces_earned}/{self.pieces_required})"
```

**Mapping**:
- `user_id: str` ‚Üí `ForeignKey(User, on_delete=CASCADE)`
- `reward_id: str` ‚Üí `ForeignKey(Reward, on_delete=CASCADE)`
- `status` ‚Üí `@property` computed field (replaces Airtable formula)
- `pieces_required` ‚Üí `@property` lookup via FK (replaces Airtable linked field)
- Add `unique_together` constraint to prevent duplicates

#### HabitLog Model
```python
class HabitLog(models.Model):
    """Habit completion log entry."""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='habit_logs')
    habit = models.ForeignKey(Habit, on_delete=models.CASCADE, related_name='logs')
    reward = models.ForeignKey(Reward, on_delete=models.SET_NULL, null=True, blank=True, related_name='awarded_in_logs')
    timestamp = models.DateTimeField(auto_now_add=True)
    got_reward = models.BooleanField(default=False)
    streak_count = models.IntegerField(default=1)
    habit_weight = models.IntegerField()
    total_weight_applied = models.FloatField()
    last_completed_date = models.DateField()

    class Meta:
        db_table = 'habit_logs'
        indexes = [
            models.Index(fields=['user', 'habit', '-timestamp']),
            models.Index(fields=['user', '-timestamp']),
            models.Index(fields=['last_completed_date']),
        ]
        ordering = ['-timestamp']

    def __str__(self):
        return f"{self.user.name} - {self.habit.name} ({self.timestamp.date()})"
```

**Mapping**:
- All `_id` fields ‚Üí Django `ForeignKey`
- `reward_id: str | None` ‚Üí `ForeignKey(Reward, on_delete=SET_NULL, null=True)`
- `timestamp: datetime` ‚Üí `DateTimeField(auto_now_add=True)`
- Add composite index on `(user, habit, timestamp DESC)` for streak calculations
- Add index on `last_completed_date` for date-based queries

### 1.3 Django Settings (replaces `src/config.py`)

**File**: `src/habit_reward_project/settings.py`

```python
import os
from pathlib import Path
import environ

env = environ.Env(
    DEBUG=(bool, False),
    DATABASE_URL=(str, 'sqlite:///db.sqlite3'),
)

BASE_DIR = Path(__file__).resolve().parent.parent

# Read .env file
environ.Env.read_env(os.path.join(BASE_DIR.parent, '.env'))

# Security
SECRET_KEY = env('SECRET_KEY')
DEBUG = env('DEBUG')
ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost', '127.0.0.1'])

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'src.core',  # Core models
]

# Database
DATABASES = {
    'default': env.db('DATABASE_URL', default='sqlite:///db.sqlite3')
}

# For PostgreSQL production:
# DATABASE_URL=postgresql://user:password@localhost:5432/habit_reward

# Telegram Bot
TELEGRAM_BOT_TOKEN = env('TELEGRAM_BOT_TOKEN')
TELEGRAM_WEBHOOK_URL = env('TELEGRAM_WEBHOOK_URL', default=None)

# LLM
LLM_PROVIDER = env('LLM_PROVIDER', default='openai')
LLM_MODEL = env('LLM_MODEL', default='gpt-3.5-turbo')
LLM_API_KEY = env('LLM_API_KEY', default=None)

# Game Settings
STREAK_MULTIPLIER_RATE = env.float('STREAK_MULTIPLIER_RATE', default=0.1)
PROGRESS_BAR_LENGTH = env.int('PROGRESS_BAR_LENGTH', default=10)
RECENT_LOGS_LIMIT = env.int('RECENT_LOGS_LIMIT', default=10)

# i18n
SUPPORTED_LANGUAGES = env.list('SUPPORTED_LANGUAGES', default=['en', 'ru', 'kk'])
DEFAULT_LANGUAGE = env('DEFAULT_LANGUAGE', default='en')

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files
STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
```

**Environment Variables** (update `.env.example`):
```
# Django
SECRET_KEY=your-secret-key-here
DEBUG=True
ALLOWED_HOSTS=localhost,127.0.0.1

# Database (SQLite for dev, PostgreSQL for prod)
DATABASE_URL=sqlite:///db.sqlite3
# DATABASE_URL=postgresql://user:password@localhost:5432/habit_reward

# Telegram
TELEGRAM_BOT_TOKEN=your-bot-token
TELEGRAM_WEBHOOK_URL=https://yourdomain.com/webhook/telegram

# LLM
LLM_PROVIDER=openai
LLM_MODEL=gpt-3.5-turbo
OPENAI_API_KEY=sk-...

# Game Settings
STREAK_MULTIPLIER_RATE=0.1
PROGRESS_BAR_LENGTH=10
RECENT_LOGS_LIMIT=10

# i18n
SUPPORTED_LANGUAGES=en,ru,kk
DEFAULT_LANGUAGE=en
```

### 1.4 Repository Layer Migration

**Create**: `src/core/repositories.py` (backward compatibility layer)

Replace Airtable repositories with Django ORM wrappers to maintain the same interface:

```python
from src.core.models import User, Habit, HabitLog, Reward, RewardProgress

class UserRepository:
    """User repository using Django ORM."""

    def get_by_telegram_id(self, telegram_id: str) -> User | None:
        """Get user by Telegram ID."""
        try:
            return User.objects.get(telegram_id=telegram_id)
        except User.DoesNotExist:
            return None

    def get_by_id(self, user_id: int) -> User | None:
        """Get user by primary key."""
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None

    def create(self, telegram_id: str, name: str, **kwargs) -> User:
        """Create new user."""
        return User.objects.create(
            telegram_id=telegram_id,
            name=name,
            **kwargs
        )

    def update(self, user_id: int, **fields) -> User:
        """Update user fields."""
        User.objects.filter(pk=user_id).update(**fields)
        return User.objects.get(pk=user_id)


class HabitRepository:
    """Habit repository using Django ORM."""

    def get_by_name(self, name: str) -> Habit | None:
        """Get habit by name."""
        try:
            return Habit.objects.get(name=name, active=True)
        except Habit.DoesNotExist:
            return None

    def get_all_active(self) -> list[Habit]:
        """Get all active habits."""
        return list(Habit.objects.filter(active=True))

    def create(self, name: str, weight: int = 10, **kwargs) -> Habit:
        """Create new habit."""
        return Habit.objects.create(name=name, weight=weight, **kwargs)

    def update(self, habit_id: int, **fields) -> Habit:
        """Update habit fields."""
        Habit.objects.filter(pk=habit_id).update(**fields)
        return Habit.objects.get(pk=habit_id)

    def soft_delete(self, habit_id: int) -> Habit:
        """Soft delete habit (set active=False)."""
        return self.update(habit_id, active=False)


class RewardRepository:
    """Reward repository using Django ORM."""

    def get_all_active(self) -> list[Reward]:
        """Get all active rewards."""
        return list(Reward.objects.filter(active=True))

    def get_by_id(self, reward_id: int) -> Reward | None:
        """Get reward by ID."""
        try:
            return Reward.objects.get(pk=reward_id)
        except Reward.DoesNotExist:
            return None

    def get_by_name(self, name: str) -> Reward | None:
        """Get reward by name."""
        try:
            return Reward.objects.get(name=name, active=True)
        except Reward.DoesNotExist:
            return None

    def create(self, name: str, **kwargs) -> Reward:
        """Create new reward."""
        return Reward.objects.create(name=name, **kwargs)


class RewardProgressRepository:
    """Reward progress repository using Django ORM."""

    def get_by_user_and_reward(self, user_id: int, reward_id: int) -> RewardProgress | None:
        """Get progress for user and reward."""
        try:
            return RewardProgress.objects.select_related('reward').get(
                user_id=user_id,
                reward_id=reward_id
            )
        except RewardProgress.DoesNotExist:
            return None

    def get_all_by_user(self, user_id: int) -> list[RewardProgress]:
        """Get all progress entries for user."""
        return list(
            RewardProgress.objects.filter(user_id=user_id)
            .select_related('reward')
            .order_by('reward__name')
        )

    def get_achieved_by_user(self, user_id: int) -> list[RewardProgress]:
        """Get achieved rewards for user."""
        from django.db.models import F
        return list(
            RewardProgress.objects.filter(
                user_id=user_id,
                pieces_earned__gte=F('reward__pieces_required'),
                claimed=False
            ).select_related('reward')
        )

    def create(self, user_id: int, reward_id: int, pieces_earned: int = 0) -> RewardProgress:
        """Create new progress entry."""
        progress, created = RewardProgress.objects.get_or_create(
            user_id=user_id,
            reward_id=reward_id,
            defaults={'pieces_earned': pieces_earned}
        )
        return progress

    def update(self, progress_id: int, **fields) -> RewardProgress:
        """Update progress fields."""
        RewardProgress.objects.filter(pk=progress_id).update(**fields)
        return RewardProgress.objects.select_related('reward').get(pk=progress_id)


class HabitLogRepository:
    """Habit log repository using Django ORM."""

    def create(self, user_id: int, habit_id: int, **kwargs) -> HabitLog:
        """Create new habit log entry."""
        return HabitLog.objects.create(
            user_id=user_id,
            habit_id=habit_id,
            **kwargs
        )

    def get_latest_for_habit(self, user_id: int, habit_id: int) -> HabitLog | None:
        """Get most recent log for user and habit."""
        try:
            return HabitLog.objects.filter(
                user_id=user_id,
                habit_id=habit_id
            ).latest('timestamp')
        except HabitLog.DoesNotExist:
            return None

    def get_today_logs_with_reward(self, user_id: int) -> list[HabitLog]:
        """Get today's logs that had meaningful rewards."""
        from django.utils import timezone
        today = timezone.now().date()
        return list(
            HabitLog.objects.filter(
                user_id=user_id,
                timestamp__date=today,
                got_reward=True
            ).select_related('reward')
        )


# Singleton instances (for backward compatibility)
user_repository = UserRepository()
habit_repository = HabitRepository()
reward_repository = RewardRepository()
reward_progress_repository = RewardProgressRepository()
habit_log_repository = HabitLogRepository()
```

**Key Design Decisions**:
1. **Same interface**: Repository methods maintain identical signatures to existing `src/airtable/repositories.py`
2. **Django ORM**: Replace Airtable API calls with Django ORM queries
3. **select_related**: Use eager loading to avoid N+1 queries
4. **Computed fields**: `RewardProgress.status` and `pieces_required` are now `@property` methods on the model (no longer Airtable formulas)
5. **Singleton pattern**: Keep same global instances for drop-in replacement

### 1.5 Service Layer Updates

**Files**: `src/services/*.py` - Minimal changes needed

Update imports to use Django repositories:

```python
# Old import (Airtable)
from src.airtable.repositories import user_repository, habit_repository, ...

# New import (Django)
from src.core.repositories import user_repository, habit_repository, ...
```

**Update configuration references**:

```python
# Old (pydantic-settings)
from src.config import settings

# New (Django settings)
from django.conf import settings
```

**Files to update**:
- `src/services/habit_service.py` - Line 8-12 (imports)
- `src/services/streak_service.py` - Line 6-8 (imports)
- `src/services/reward_service.py` - Line 7-11 (imports)
- `src/services/nlp_service.py` - Line 5-6 (settings import)

**No other changes needed** - Services are already framework-agnostic.

### 1.6 Database Migrations

**Create initial migration**:
```bash
python manage.py makemigrations core
python manage.py migrate
```

**Data Migration Script** (if migrating from Airtable):

**File**: `src/core/management/commands/migrate_from_airtable.py`

```python
from django.core.management.base import BaseCommand
from pyairtable import Api
from src.core.models import User, Habit, Reward, RewardProgress, HabitLog
import os

class Command(BaseCommand):
    help = 'Migrate data from Airtable to Django database'

    def handle(self, *args, **options):
        # Connect to Airtable
        api = Api(os.getenv('AIRTABLE_API_KEY'))
        base = api.base(os.getenv('AIRTABLE_BASE_ID'))

        # Migrate users
        self.stdout.write('Migrating users...')
        users_table = base.table('Users')
        for record in users_table.all():
            fields = record['fields']
            User.objects.update_or_create(
                telegram_id=str(fields['telegram_id']),
                defaults={
                    'name': fields['name'],
                    'active': fields.get('active', False),
                    'language': fields.get('language', 'en'),
                }
            )

        # Migrate habits, rewards, logs, progress...
        # Similar pattern for other tables

        self.stdout.write(self.style.SUCCESS('Migration completed'))
```

**Run migration**:
```bash
python manage.py migrate_from_airtable
```

## Phase 2A: Telegram Webhook Setup

### 2.1 Webhook Handler (replaces polling in `src/bot/main.py:163`)

**File**: `src/bot/webhook_handler.py` (new file)

```python
from telegram import Update
from telegram.ext import Application, ContextTypes
from django.http import HttpResponse, HttpResponseBadRequest
from django.views.decorators.csrf import csrf_exempt
from django.conf import settings
import json
import logging

logger = logging.getLogger(__name__)

# Initialize application (singleton)
application = Application.builder().token(settings.TELEGRAM_BOT_TOKEN).build()


async def setup_handlers():
    """Register all bot handlers (same as current main.py)."""
    from src.bot.main import (
        start_command, help_command,
        # Import all other handlers...
    )

    # Register command handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    # ... register all other handlers from current main.py

    logger.info("‚úÖ All Telegram handlers registered")


@csrf_exempt
async def telegram_webhook(request):
    """Handle incoming Telegram webhook requests."""
    if request.method != 'POST':
        return HttpResponseBadRequest('Only POST requests are allowed')

    try:
        # Parse update
        update_data = json.loads(request.body)
        update = Update.de_json(update_data, application.bot)

        # Process update
        await application.process_update(update)

        return HttpResponse('ok')

    except Exception as e:
        logger.error(f"‚ùå Error processing webhook: {e}")
        return HttpResponseBadRequest(str(e))
```

**Django URL routing** - **File**: `src/habit_reward_project/urls.py`

```python
from django.contrib import admin
from django.urls import path
from src.bot.webhook_handler import telegram_webhook

urlpatterns = [
    path('admin/', admin.site.urls),
    path('webhook/telegram', telegram_webhook, name='telegram_webhook'),
]
```

### 2.2 Webhook Registration

**File**: `src/core/management/commands/set_webhook.py` (new Django management command)

```python
from django.core.management.base import BaseCommand
from django.conf import settings
import telegram
import asyncio

class Command(BaseCommand):
    help = 'Set Telegram webhook URL'

    async def set_webhook_async(self):
        bot = telegram.Bot(settings.TELEGRAM_BOT_TOKEN)
        webhook_url = settings.TELEGRAM_WEBHOOK_URL

        if not webhook_url:
            self.stdout.write(self.style.ERROR('TELEGRAM_WEBHOOK_URL not set in settings'))
            return

        # Set webhook
        await bot.set_webhook(url=webhook_url)

        # Verify
        webhook_info = await bot.get_webhook_info()
        self.stdout.write(self.style.SUCCESS(f'‚úÖ Webhook set: {webhook_info.url}'))
        self.stdout.write(f'Pending updates: {webhook_info.pending_update_count}')

    def handle(self, *args, **options):
        asyncio.run(self.set_webhook_async())
```

**Run webhook setup**:
```bash
python manage.py set_webhook
```

### 2.3 Update Bot Main Entry Point

**File**: `src/bot/main.py`

**Remove**:
- Line 163: `application.run_polling(allowed_updates=Update.ALL_TYPES)`

**Keep**:
- All handler registrations (will be imported by webhook_handler.py)
- All command handler functions

**Add fallback for local development**:
```python
if __name__ == "__main__":
    # Local development mode: use polling
    from django.conf import settings
    import django

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'src.habit_reward_project.settings')
    django.setup()

    from telegram.ext import Application

    application = Application.builder().token(settings.TELEGRAM_BOT_TOKEN).build()

    # Register all handlers
    # ... (keep existing handler registration code)

    logger.info("ü§ñ Running bot in POLLING mode (development)")
    application.run_polling(allowed_updates=Update.ALL_TYPES)
```

### 2.4 Production Deployment (Webhooks)

**ASGI Server** (for async webhook handling):

**File**: `src/habit_reward_project/asgi.py` (update)

```python
import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'src.habit_reward_project.settings')

# Initialize Django ASGI application early
django_asgi_app = get_asgi_application()

# Setup bot handlers after Django is initialized
from src.bot.webhook_handler import setup_handlers
import asyncio
asyncio.create_task(setup_handlers())

application = django_asgi_app
```

**Run with Uvicorn**:
```bash
# Development
uvicorn src.habit_reward_project.asgi:application --reload --port 8000

# Production
uvicorn src.habit_reward_project.asgi:application --host 0.0.0.0 --port 8000 --workers 4
```

**Nginx reverse proxy** (for HTTPS webhook):
```nginx
server {
    listen 443 ssl;
    server_name yourdomain.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;

    location /webhook/telegram {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

## Phase 2B: Configuration & Admin

### 2.5 Django Admin Interface

**File**: `src/core/admin.py`

```python
from django.contrib import admin
from src.core.models import User, Habit, Reward, RewardProgress, HabitLog


@admin.register(User)
class UserAdmin(admin.ModelAdmin):
    list_display = ['telegram_id', 'name', 'active', 'language', 'created_at']
    list_filter = ['active', 'language']
    search_fields = ['telegram_id', 'name']
    readonly_fields = ['created_at', 'updated_at']


@admin.register(Habit)
class HabitAdmin(admin.ModelAdmin):
    list_display = ['name', 'weight', 'category', 'active', 'created_at']
    list_filter = ['active', 'category']
    search_fields = ['name']


@admin.register(Reward)
class RewardAdmin(admin.ModelAdmin):
    list_display = ['name', 'type', 'weight', 'pieces_required', 'piece_value', 'active']
    list_filter = ['type', 'active']
    search_fields = ['name']


@admin.register(RewardProgress)
class RewardProgressAdmin(admin.ModelAdmin):
    list_display = ['user', 'reward', 'pieces_earned', 'pieces_required', 'status', 'claimed']
    list_filter = ['claimed']
    search_fields = ['user__name', 'reward__name']
    readonly_fields = ['status', 'pieces_required']

    def status(self, obj):
        return obj.status
    status.short_description = 'Status'

    def pieces_required(self, obj):
        return obj.pieces_required
    pieces_required.short_description = 'Required'


@admin.register(HabitLog)
class HabitLogAdmin(admin.ModelAdmin):
    list_display = ['user', 'habit', 'timestamp', 'streak_count', 'got_reward', 'reward']
    list_filter = ['got_reward', 'timestamp']
    search_fields = ['user__name', 'habit__name']
    readonly_fields = ['timestamp']
    date_hierarchy = 'timestamp'
```

**Benefits**:
- Web UI for managing users, habits, rewards
- Replaces Airtable admin interface
- Search, filter, bulk operations
- Accessible at `/admin/`

### 2.6 Streamlit Dashboard Updates

**File**: `src/dashboard/app.py`

Update to use Django models instead of Airtable:

```python
import os
import django

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'src.habit_reward_project.settings')
django.setup()

# Now import Django models
from src.core.models import User, Habit, HabitLog, Reward, RewardProgress

# Rest of dashboard code remains the same
# Just replace repository calls with Django ORM queries
```

## Phase 3: Testing & Deployment

### 3.1 Update Tests

**Files**: `tests/*.py`

Update all test files to mock Django models instead of Airtable repositories:

```python
# Old (Airtable mocking)
@patch('src.bot.main.user_repository')
async def test_start_command(mock_user_repo):
    mock_user_repo.get_by_telegram_id.return_value = None

# New (Django mocking)
@patch('src.core.repositories.User.objects')
async def test_start_command(mock_user_objects):
    mock_user_objects.get.side_effect = User.DoesNotExist
```

### 3.2 Migration Checklist

**Pre-migration**:
- [ ] Backup Airtable data
- [ ] Test Django models locally with SQLite
- [ ] Run test suite: `pytest tests/ -v`
- [ ] Verify all handlers work with Django ORM

**Migration**:
- [ ] Run `python manage.py migrate` (create tables)
- [ ] Run `python manage.py migrate_from_airtable` (import data)
- [ ] Verify data integrity (counts, relationships)
- [ ] Create Django superuser: `python manage.py createsuperuser`
- [ ] Test admin interface at `/admin/`

**Webhook setup**:
- [ ] Deploy Django app with HTTPS
- [ ] Set `TELEGRAM_WEBHOOK_URL` in production `.env`
- [ ] Run `python manage.py set_webhook`
- [ ] Verify webhook: `python manage.py check_webhook` (create this command)
- [ ] Test bot commands via Telegram

**Production**:
- [ ] Switch `DATABASE_URL` to PostgreSQL
- [ ] Run migrations on production DB
- [ ] Configure Nginx/reverse proxy
- [ ] Start ASGI server with Uvicorn
- [ ] Monitor logs for errors

### 3.3 Rollback Plan

If issues occur during migration:

1. **Keep Airtable temporarily**: Don't delete Airtable base immediately
2. **Switch back**: Change imports from `src.core.repositories` to `src.airtable.repositories`
3. **Revert to polling**: Use `python src/bot/main.py` with polling mode
4. **Debug offline**: Fix Django issues without affecting production bot

### 3.4 Performance Optimization

**Database indexes** (already included in models):
- `User.telegram_id` - Unique index for fast lookups
- `Habit(active, name)` - Composite index for filtering
- `RewardProgress(user, reward)` - Unique together constraint + index
- `HabitLog(user, habit, -timestamp)` - For streak calculations

**Query optimization**:
- Use `select_related()` for foreign keys (avoid N+1 queries)
- Use `prefetch_related()` for reverse foreign keys
- Add database connection pooling in production

**Webhook scalability**:
- Async ASGI server handles concurrent requests
- Stateless handlers (no session storage)
- Can scale horizontally (multiple Uvicorn workers)

## Files Summary

### New Files
- `src/habit_reward_project/settings.py` - Django settings
- `src/habit_reward_project/urls.py` - URL routing
- `src/habit_reward_project/asgi.py` - ASGI config
- `src/habit_reward_project/wsgi.py` - WSGI config
- `src/core/models.py` - Django models
- `src/core/repositories.py` - Repository layer
- `src/core/admin.py` - Django admin config
- `src/core/management/commands/set_webhook.py` - Webhook setup command
- `src/core/management/commands/migrate_from_airtable.py` - Data migration
- `src/bot/webhook_handler.py` - Webhook endpoint
- `manage.py` - Django CLI

### Modified Files
- `pyproject.toml` - Update dependencies (add Django, remove pyairtable)
- `src/bot/main.py` - Remove polling, add development fallback
- `src/services/*.py` - Update imports (4 files)
- `src/dashboard/app.py` - Use Django models
- `tests/*.py` - Update mocking for Django
- `.env.example` - Add Django settings

### Removed Files (after migration)
- `src/airtable/client.py` - No longer needed
- `src/airtable/repositories.py` - Replaced by Django repositories
- `src/config.py` - Replaced by Django settings

## Implementation Notes

**SQLite ‚Üí PostgreSQL Migration**:
Django supports both with zero code changes. Just update `DATABASE_URL`:
```
# Development
DATABASE_URL=sqlite:///db.sqlite3

# Production
DATABASE_URL=postgresql://user:pass@host:5432/dbname
```

**Webhook vs Polling Trade-offs**:
- **Webhooks**: Lower latency, better scalability, requires HTTPS
- **Polling**: Simpler deployment, works without HTTPS, higher resource usage
- Keep polling mode for local development (easier debugging)

**Django Benefits**:
- Built-in admin interface (replaces Airtable UI)
- Powerful ORM (no manual SQL)
- Migration system (version control for schema)
- PostgreSQL full-text search, JSON fields, etc.
- Ecosystem: Django REST Framework, Celery, etc.

**Backward Compatibility**:
Repository layer maintains same interface, so services and handlers require minimal changes. This allows gradual migration and easy rollback.
