# Feature 0022: Comprehensive REST API Implementation

## Overview
Introduce a full internal REST API that exposes all core functions over HTTP to enable future mobile app and web frontend development. The API will provide comprehensive feature parity with the existing Telegram bot, allowing external clients to perform all habit tracking, reward management, and user operations.

## Technical Approach

### Framework Selection: FastAPI
- **Rationale**: FastAPI 0.104+ already in dependencies, native async support, automatic OpenAPI documentation, excellent performance, Pydantic integration
- **Alternative Considered**: Django REST Framework (DRF) - rejected because it requires more boilerplate and lacks native async support
- **Integration**: Run alongside existing Django application using ASGI server (uvicorn)

### Architecture Overview
```
Mobile/Web Client
    ↓ HTTP/JSON
FastAPI REST API Layer (new)
    ↓
Existing Service Layer (reuse)
    ↓
Django ORM Repositories (reuse)
    ↓
PostgreSQL/SQLite
```

The existing service layer (`src/services/`) will be reused without modification. API endpoints will call services and serialize Pydantic models to JSON.

---

## Phase 1: Foundation & Authentication

### 1.1 Project Structure Changes

**New Directories:**
- `src/api/` - Root API package
- `src/api/v1/` - Version 1 endpoints
- `src/api/v1/routers/` - Route modules by resource
- `src/api/middleware/` - Custom middleware
- `src/api/schemas/` - Request/response schemas (if extending Pydantic models)
- `src/api/dependencies/` - Dependency injection utilities
- `src/api/exceptions.py` - API-specific exception handlers
- `src/api/main.py` - FastAPI application factory

**New Files to Create:**
- `src/api/__init__.py`
- `src/api/main.py` - FastAPI app initialization
- `src/api/v1/__init__.py`
- `src/api/v1/routers/__init__.py`
- `src/api/v1/routers/auth.py` - Authentication endpoints
- `src/api/v1/routers/users.py` - User management
- `src/api/v1/routers/habits.py` - Habit CRUD + operations
- `src/api/v1/routers/rewards.py` - Reward CRUD + operations
- `src/api/v1/routers/habit_logs.py` - Habit completion logs
- `src/api/v1/routers/streaks.py` - Streak information
- `src/api/dependencies/auth.py` - Authentication dependencies
- `src/api/middleware/logging.py` - Request/response logging
- `src/api/exceptions.py` - Exception handlers

### 1.2 Authentication Strategy

**Approach: JWT (JSON Web Tokens)**
- **Token Types:**
  - Access Token: Short-lived (15 minutes), used for API requests
  - Refresh Token: Long-lived (7 days), used to obtain new access tokens

**Token Payload:**
```json
{
  "sub": "user_id",  // Django User.id
  "telegram_id": 123456789,  // Optional, for Telegram users
  "exp": 1234567890,  // Expiration timestamp
  "type": "access" | "refresh"
}
```

**Authentication Flow:**
1. Client sends credentials (telegram_id or username/password)
2. Server validates credentials against Django User model
3. Server generates access + refresh tokens
4. Client stores tokens (secure storage)
5. Client includes access token in `Authorization: Bearer <token>` header
6. Server validates token on each request via dependency injection

**Files to Modify:**
- `src/core/models.py` - Add `User.last_login` field (already exists in AbstractUser)

**New Dependencies:**
- `python-jose[cryptography]` - JWT encoding/decoding
- `passlib[bcrypt]` - Password hashing (for non-Telegram users)

**Implementation Details:**

**File: `src/api/dependencies/auth.py`**
- `get_current_user()` - Dependency that extracts JWT from header, validates, returns User
- `get_current_active_user()` - Wrapper that also checks `user.is_active`
- `create_access_token()` - Generate JWT access token
- `create_refresh_token()` - Generate JWT refresh token
- `verify_token()` - Decode and validate JWT

**File: `src/api/v1/routers/auth.py`**
Endpoints:
- `POST /api/v1/auth/login` - Login with telegram_id or username/password
  - Request: `{"telegram_id": 123456789}` or `{"username": "foo", "password": "bar"}`
  - Response: `{"access_token": "...", "refresh_token": "...", "token_type": "bearer"}`
  - Calls: `user_repository.get_by_telegram_id()` or `user_repository.get_by_username()`

- `POST /api/v1/auth/refresh` - Refresh access token
  - Request: `{"refresh_token": "..."}`
  - Response: `{"access_token": "...", "token_type": "bearer"}`

- `POST /api/v1/auth/logout` - Invalidate refresh token (optional, can use token blacklist)
  - Request: `{"refresh_token": "..."}`
  - Response: `{"message": "Logged out successfully"}`

**File: `src/api/main.py`**
```python
from fastapi import FastAPI
from src.api.v1.routers import auth, users, habits, rewards, habit_logs, streaks
from src.api.middleware.logging import LoggingMiddleware
from src.api.exceptions import setup_exception_handlers

def create_app() -> FastAPI:
    app = FastAPI(
        title="Habit Reward API",
        version="1.0.0",
        docs_url="/api/docs",
        openapi_url="/api/openapi.json"
    )

    # Middleware
    app.add_middleware(LoggingMiddleware)

    # Exception handlers
    setup_exception_handlers(app)

    # Routers
    app.include_router(auth.router, prefix="/api/v1/auth", tags=["Authentication"])
    app.include_router(users.router, prefix="/api/v1/users", tags=["Users"])
    app.include_router(habits.router, prefix="/api/v1/habits", tags=["Habits"])
    app.include_router(rewards.router, prefix="/api/v1/rewards", tags=["Rewards"])
    app.include_router(habit_logs.router, prefix="/api/v1/habit-logs", tags=["Habit Logs"])
    app.include_router(streaks.router, prefix="/api/v1/streaks", tags=["Streaks"])

    return app

app = create_app()
```

### 1.3 Exception Handling

**File: `src/api/exceptions.py`**

Custom exception classes:
- `APIException` - Base exception
- `UnauthorizedException` - 401 errors
- `ForbiddenException` - 403 errors
- `NotFoundException` - 404 errors
- `ConflictException` - 409 errors (duplicate entries)
- `ValidationException` - 422 errors (business logic validation)

Exception handler registration:
- Map service-level exceptions to HTTP status codes
- Standardized error response format:
  ```json
  {
    "error": {
      "code": "HABIT_NOT_FOUND",
      "message": "Habit 'Morning Run' not found",
      "details": {}
    }
  }
  ```

---

## Phase 2A: User & Habit Management API

### 2A.1 User Endpoints

**File: `src/api/v1/routers/users.py`**

Endpoints:
- `GET /api/v1/users/me` - Get current authenticated user
  - Dependencies: `get_current_active_user()`
  - Response: User model (Pydantic)
  - Calls: Returns user from dependency (already fetched)

- `PATCH /api/v1/users/me` - Update user profile
  - Request: `{"name": "...", "language": "en"}`
  - Response: Updated User model
  - Calls: `user_repository.update()`

- `GET /api/v1/users/me/settings` - Get user settings
  - Response: `{"language": "en", "timezone": "UTC"}`
  - Calls: Returns user.language from DB

### 2A.2 Habit CRUD Endpoints

**File: `src/api/v1/routers/habits.py`**

Endpoints:
- `GET /api/v1/habits` - List all active habits for current user
  - Query params: `?active=true` (default), `?category=health`
  - Response: `{"habits": [Habit, ...]}`
  - Calls: `habit_repository.get_all_by_user(user.id, active=True)`

- `GET /api/v1/habits/{habit_id}` - Get single habit
  - Path param: `habit_id` (int)
  - Response: Habit model
  - Calls: `habit_repository.get_by_id(habit_id)` + ownership check

- `POST /api/v1/habits` - Create new habit
  - Request: `{"name": "...", "weight": 50, "category": "health", "allowed_skip_days": 1, "exempt_weekdays": [6, 0]}`
  - Response: Created Habit model
  - Calls: `habit_repository.create()`
  - Validation: name unique per user, weight 1-100

- `PATCH /api/v1/habits/{habit_id}` - Update habit
  - Request: Partial Habit fields
  - Response: Updated Habit model
  - Calls: `habit_repository.update()`

- `DELETE /api/v1/habits/{habit_id}` - Soft delete habit (set active=False)
  - Response: `{"message": "Habit deleted"}`
  - Calls: `habit_repository.update(habit_id, active=False)`

### 2A.3 Habit Completion Endpoints

**File: `src/api/v1/routers/habits.py`** (same file, different endpoints)

Endpoints:
- `POST /api/v1/habits/{habit_id}/complete` - Log habit completion
  - Request: `{"target_date": "2025-12-10"}` (optional, defaults to today)
  - Response: HabitCompletionResult (includes streak, reward, etc.)
  - Calls: `habit_service.process_habit_completion(user_id, habit_name, target_date)`
  - Validation: target_date within 0-7 days back, no duplicate entries
  - Algorithm:
    1. Validate target_date is today or up to 7 days back
    2. Check for existing log for (user, habit, target_date)
    3. Call `streak_service.calculate_streak_for_date(habit_id, target_date)`
    4. Calculate total_weight = habit_weight × (1 + streak × 0.1)
    5. Call `reward_service.select_reward(user_id, total_weight)`
    6. Update reward progress if reward awarded
    7. Create HabitLog with all metrics
    8. If backdated, recalculate streaks for all logs after target_date
    9. Return HabitCompletionResult

- `DELETE /api/v1/habits/{habit_id}/logs/{log_id}` - Revert habit completion
  - Path params: `habit_id`, `log_id`
  - Response: HabitRevertResult
  - Calls: `habit_service.revert_habit_completion(log_id)`
  - Authorization: Check log belongs to current user
  - Algorithm:
    1. Fetch HabitLog by log_id
    2. Check ownership (log.habit.user_id == current_user.id)
    3. Delete HabitLog
    4. If reward was awarded, decrement RewardProgress.pieces_earned
    5. Return HabitRevertResult

### 2A.4 Habit Logs & History

**File: `src/api/v1/routers/habit_logs.py`**

Endpoints:
- `GET /api/v1/habit-logs` - Get habit completion history
  - Query params: `?start_date=2025-12-01&end_date=2025-12-10&habit_id=5`
  - Response: `{"logs": [HabitLog, ...], "total": 42}`
  - Calls: `habit_log_repository.get_by_date_range(user_id, start_date, end_date, habit_id)`
  - Pagination: `?limit=20&offset=0`

- `GET /api/v1/habit-logs/{log_id}` - Get single habit log
  - Response: HabitLog model with full details
  - Calls: `habit_log_repository.get_by_id(log_id)` + ownership check

---

## Phase 2B: Reward & Streak API

### 2B.1 Reward Management Endpoints

**File: `src/api/v1/routers/rewards.py`**

Endpoints:
- `GET /api/v1/rewards` - List all rewards for current user
  - Query params: `?type=VIRTUAL` (filter by type), `?status=pending|achieved|claimed`
  - Response: `{"rewards": [{"reward": Reward, "progress": RewardProgress}, ...]}`
  - Calls: `reward_repository.get_all_by_user(user_id)` + `reward_progress_repository.get_by_user(user_id)`
  - Join logic: Combine rewards with their progress status

- `GET /api/v1/rewards/{reward_id}` - Get single reward with progress
  - Response: `{"reward": Reward, "progress": RewardProgress}`
  - Calls: `reward_repository.get_by_id()` + `reward_progress_repository.get_by_reward()`

- `POST /api/v1/rewards` - Create new reward
  - Request: `{"name": "...", "type": "VIRTUAL", "weight": 1.0, "pieces_required": 5, "piece_value": 10.0, "max_daily_claims": 2}`
  - Response: Created Reward model
  - Calls: `reward_repository.create()`
  - Validation: weight > 0, pieces_required >= 1, type in enum

- `PATCH /api/v1/rewards/{reward_id}` - Update reward
  - Request: Partial Reward fields
  - Response: Updated Reward model
  - Calls: `reward_repository.update()`

- `DELETE /api/v1/rewards/{reward_id}` - Delete reward
  - Response: `{"message": "Reward deleted"}`
  - Calls: `reward_repository.delete()`
  - Constraint: Cannot delete if active RewardProgress exists

### 2B.2 Reward Progress & Claiming

**File: `src/api/v1/routers/rewards.py`** (same file)

Endpoints:
- `GET /api/v1/rewards/progress` - Get all reward progress for current user
  - Response: `{"progress": [{"reward": Reward, "pieces_earned": 3, "pieces_required": 5, "status": "pending", "progress_percent": 60}, ...]}`
  - Calls: `reward_progress_repository.get_all_by_user(user_id)`
  - Computed fields: status (pending/achieved/claimed), progress_percent

- `POST /api/v1/rewards/{reward_id}/claim` - Claim achieved reward
  - Response: `{"message": "Reward claimed", "reward": Reward}`
  - Calls: `reward_service.mark_reward_claimed(user_id, reward_id)`
  - Validation: Check reward status is "achieved" (pieces_earned >= pieces_required && !claimed)
  - Algorithm:
    1. Fetch RewardProgress for (user_id, reward_id)
    2. Check pieces_earned >= reward.pieces_required
    3. Check claimed == False
    4. Set claimed = True, reset pieces_earned to 0
    5. Return success response

### 2B.3 Streak Endpoints

**File: `src/api/v1/routers/streaks.py`**

Endpoints:
- `GET /api/v1/streaks` - Get current streaks for all habits
  - Response: `{"streaks": [{"habit": Habit, "current_streak": 7, "last_completed": "2025-12-10"}, ...]}`
  - Calls: `streak_service.get_current_streak(habit_id)` for each habit
  - Algorithm:
    1. Fetch all active habits for user
    2. For each habit, get most recent HabitLog
    3. If log exists, use log.streak_count as current_streak
    4. Return list of (habit, streak_count, last_completed_date)

- `GET /api/v1/streaks/{habit_id}` - Get streak for specific habit
  - Response: `{"habit": Habit, "current_streak": 7, "last_completed": "2025-12-10", "longest_streak": 14}`
  - Calls: `streak_service.get_current_streak()` + calculate longest from logs
  - Longest streak algorithm:
    1. Fetch all HabitLogs for habit
    2. Find max(streak_count) across all logs
    3. Return as longest_streak

---

## Phase 3: Advanced Features

### 3.1 Batch Operations

**File: `src/api/v1/routers/habits.py`**

Endpoints:
- `POST /api/v1/habits/batch-complete` - Complete multiple habits at once
  - Request: `{"completions": [{"habit_id": 1, "target_date": "2025-12-10"}, {"habit_id": 2}]}`
  - Response: `{"results": [HabitCompletionResult, ...], "errors": [...]}`
  - Calls: `habit_service.process_habit_completion()` for each item
  - Transaction: Use atomic transaction, rollback all on any error (optional: partial success mode)

### 3.2 Analytics & Statistics

**File: `src/api/v1/routers/analytics.py`**

Endpoints:
- `GET /api/v1/analytics/overview` - Dashboard statistics
  - Query params: `?start_date=...&end_date=...`
  - Response:
    ```json
    {
      "total_completions": 142,
      "total_habits": 5,
      "active_streaks": 3,
      "rewards_achieved": 7,
      "rewards_claimed": 5,
      "completion_rate": 0.85,
      "top_habits": [{"habit": Habit, "completions": 42}, ...]
    }
    ```
  - Calls: Multiple repository queries + aggregation

- `GET /api/v1/analytics/habits/{habit_id}/stats` - Per-habit statistics
  - Response:
    ```json
    {
      "total_completions": 42,
      "current_streak": 7,
      "longest_streak": 14,
      "completion_by_weekday": {"Monday": 6, "Tuesday": 5, ...},
      "total_rewards_earned": 12
    }
    ```

### 3.3 Webhooks (Optional)

**File: `src/api/v1/routers/webhooks.py`**

Allow users to register webhook URLs to receive notifications:
- Habit completed
- Reward achieved
- Streak milestone reached

**Implementation:**
- New model: `Webhook(user, url, events, active)`
- Background task using Celery or asyncio to send HTTP POST to webhook URLs
- Retry logic with exponential backoff

---

## Files to Create

### Core API Files
1. `src/api/__init__.py` - Package init
2. `src/api/main.py` - FastAPI app factory (Phase 1)
3. `src/api/exceptions.py` - Exception handlers (Phase 1)
4. `src/api/v1/__init__.py` - Version 1 package init
5. `src/api/v1/routers/__init__.py` - Routers package init

### Authentication
6. `src/api/dependencies/__init__.py`
7. `src/api/dependencies/auth.py` - JWT auth dependencies (Phase 1)

### Routers
8. `src/api/v1/routers/auth.py` - Auth endpoints (Phase 1)
9. `src/api/v1/routers/users.py` - User endpoints (Phase 2A)
10. `src/api/v1/routers/habits.py` - Habit endpoints (Phase 2A)
11. `src/api/v1/routers/habit_logs.py` - Habit log endpoints (Phase 2A)
12. `src/api/v1/routers/rewards.py` - Reward endpoints (Phase 2B)
13. `src/api/v1/routers/streaks.py` - Streak endpoints (Phase 2B)
14. `src/api/v1/routers/analytics.py` - Analytics endpoints (Phase 3)

### Middleware
15. `src/api/middleware/__init__.py`
16. `src/api/middleware/logging.py` - Request/response logging (Phase 1)
17. `src/api/middleware/rate_limiting.py` - Rate limiting (Phase 3, optional)

### Configuration
18. `src/api/config.py` - API-specific config (JWT secret, token expiry, etc.)

### ASGI Entry Point
19. `asgi.py` - Root-level ASGI application entry point

---

## Files to Modify

1. `requirements.txt` or `pyproject.toml` - Add FastAPI dependencies:
   - `fastapi>=0.104.0`
   - `python-jose[cryptography]>=3.3.0`
   - `passlib[bcrypt]>=1.7.4`
   - `python-multipart>=0.0.6` (for file uploads, if needed)

2. `src/config.py` - Add API configuration:
   - `API_SECRET_KEY` - JWT signing key
   - `API_ACCESS_TOKEN_EXPIRE_MINUTES` - Access token TTL (default: 15)
   - `API_REFRESH_TOKEN_EXPIRE_DAYS` - Refresh token TTL (default: 7)
   - `API_ALGORITHM` - JWT algorithm (default: "HS256")

3. `deployment/Caddyfile` - Add reverse proxy routes:
   ```
   /api/* {
       reverse_proxy localhost:8000
   }
   ```

4. `README.md` - Add API documentation section with:
   - How to run the API server
   - Link to OpenAPI docs at `/api/docs`
   - Authentication flow examples

---

## ASGI Application Entry Point

**File: `asgi.py`** (root level)
```python
import os
import django
from django.core.asgi import get_asgi_application

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'src.habit_reward_project.settings')
django.setup()

# Import FastAPI app after Django setup
from src.api.main import app as fastapi_app

# Get Django ASGI app
django_asgi_app = get_asgi_application()

# Mount both applications
from fastapi import FastAPI
from fastapi.middleware.wsgi import WSGIMiddleware

# Create root app
app = FastAPI()

# Mount FastAPI app
app.mount("/api", fastapi_app)

# Mount Django app for admin interface
app.mount("/", WSGIMiddleware(django_asgi_app))
```

**Run Command:**
```bash
uvicorn asgi:app --reload --port 8000
```

This allows both Django admin (`/admin`) and FastAPI (`/api`) to coexist.

---

## API Endpoint Summary

### Authentication
- `POST /api/v1/auth/login` - Login
- `POST /api/v1/auth/refresh` - Refresh token
- `POST /api/v1/auth/logout` - Logout

### Users
- `GET /api/v1/users/me` - Get current user
- `PATCH /api/v1/users/me` - Update user
- `GET /api/v1/users/me/settings` - Get settings

### Habits
- `GET /api/v1/habits` - List habits
- `GET /api/v1/habits/{id}` - Get habit
- `POST /api/v1/habits` - Create habit
- `PATCH /api/v1/habits/{id}` - Update habit
- `DELETE /api/v1/habits/{id}` - Delete habit
- `POST /api/v1/habits/{id}/complete` - Complete habit
- `POST /api/v1/habits/batch-complete` - Batch complete

### Habit Logs
- `GET /api/v1/habit-logs` - List logs (with filters)
- `GET /api/v1/habit-logs/{id}` - Get log
- `DELETE /api/v1/habits/{habit_id}/logs/{log_id}` - Revert completion

### Rewards
- `GET /api/v1/rewards` - List rewards (with progress)
- `GET /api/v1/rewards/{id}` - Get reward
- `POST /api/v1/rewards` - Create reward
- `PATCH /api/v1/rewards/{id}` - Update reward
- `DELETE /api/v1/rewards/{id}` - Delete reward
- `GET /api/v1/rewards/progress` - Get all progress
- `POST /api/v1/rewards/{id}/claim` - Claim reward

### Streaks
- `GET /api/v1/streaks` - Get all streaks
- `GET /api/v1/streaks/{habit_id}` - Get habit streak

### Analytics
- `GET /api/v1/analytics/overview` - Dashboard stats
- `GET /api/v1/analytics/habits/{id}/stats` - Per-habit stats

---

## Security Considerations

### 1. Rate Limiting
- Implement per-user rate limiting (e.g., 100 requests per minute)
- Use `slowapi` library or custom middleware
- Store rate limit state in Redis (optional) or in-memory cache

### 2. CORS Configuration
- Allow specific origins for web frontend
- Configure in FastAPI app:
  ```python
  from fastapi.middleware.cors import CORSMiddleware
  app.add_middleware(
      CORSMiddleware,
      allow_origins=["https://yourfrontend.com"],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
  )
  ```

### 3. Input Validation
- All request bodies validated via Pydantic schemas
- Additional business logic validation in services
- Sanitize user input to prevent injection attacks

### 4. Authorization
- All endpoints (except `/auth/login`) require valid JWT
- Resource ownership checks: users can only access their own data
- Use dependency injection for consistent auth checks

### 5. HTTPS Only
- Enforce HTTPS in production via Caddy reverse proxy
- JWT tokens only transmitted over secure connections

---

## Testing Strategy

### Unit Tests

**File: `tests/api/test_auth.py`**
- Test `create_access_token()` - verify payload, expiration
- Test `create_refresh_token()` - verify payload, expiration
- Test `verify_token()` - valid token, expired token, invalid signature
- Test `get_current_user()` - extract user from token, handle missing token

**File: `tests/api/test_users.py`**
- Test `GET /api/v1/users/me` - returns current user
- Test `PATCH /api/v1/users/me` - updates user, validates fields
- Test `GET /api/v1/users/me/settings` - returns settings

**File: `tests/api/test_habits.py`**
- Test `GET /api/v1/habits` - returns user's habits, filters by active/category
- Test `POST /api/v1/habits` - creates habit, validates weight range (1-100)
- Test `POST /api/v1/habits` - rejects duplicate name for same user
- Test `PATCH /api/v1/habits/{id}` - updates habit, rejects non-owner
- Test `DELETE /api/v1/habits/{id}` - soft deletes, rejects non-owner
- Test `POST /api/v1/habits/{id}/complete` - calls service, returns result
- Test `POST /api/v1/habits/{id}/complete` - rejects future dates
- Test `POST /api/v1/habits/{id}/complete` - rejects dates > 7 days back
- Test `POST /api/v1/habits/{id}/complete` - prevents duplicate completions
- Test `DELETE /api/v1/habits/{habit_id}/logs/{log_id}` - reverts completion

**File: `tests/api/test_rewards.py`**
- Test `GET /api/v1/rewards` - returns rewards with progress
- Test `GET /api/v1/rewards` - filters by type, status
- Test `POST /api/v1/rewards` - creates reward, validates fields
- Test `PATCH /api/v1/rewards/{id}` - updates reward
- Test `DELETE /api/v1/rewards/{id}` - deletes reward, blocks if progress exists
- Test `POST /api/v1/rewards/{id}/claim` - claims achieved reward
- Test `POST /api/v1/rewards/{id}/claim` - rejects if not achieved
- Test `POST /api/v1/rewards/{id}/claim` - rejects if already claimed

**File: `tests/api/test_streaks.py`**
- Test `GET /api/v1/streaks` - returns all habit streaks
- Test `GET /api/v1/streaks/{id}` - returns habit streak with longest

**File: `tests/api/test_habit_logs.py`**
- Test `GET /api/v1/habit-logs` - returns logs with date filters
- Test `GET /api/v1/habit-logs` - pagination works correctly
- Test `GET /api/v1/habit-logs/{id}` - returns single log
- Test `GET /api/v1/habit-logs/{id}` - rejects non-owner access

### Integration Tests

**File: `tests/api/test_integration.py`**
- Test full habit completion flow:
  1. Create habit via API
  2. Complete habit via API
  3. Verify HabitLog created
  4. Verify streak calculated
  5. Verify reward awarded (if applicable)
  6. Verify RewardProgress updated
  7. Claim reward via API
  8. Verify progress reset

- Test backdate completion flow:
  1. Complete habit for past date
  2. Verify streak calculated for that date
  3. Complete habit for today
  4. Verify subsequent logs recalculated

- Test authentication flow:
  1. Login with credentials
  2. Receive tokens
  3. Access protected endpoint with access token
  4. Refresh token when expired
  5. Access endpoint with new token

### Edge Cases & Error Scenarios

- **Invalid JWT**: Return 401 Unauthorized
- **Expired JWT**: Return 401 Unauthorized with `token_expired` error code
- **Accessing another user's resource**: Return 403 Forbidden
- **Habit not found**: Return 404 Not Found
- **Duplicate habit completion**: Return 409 Conflict
- **Invalid date range**: Return 422 Validation Error
- **Claiming unclaimed reward**: Return 422 Validation Error
- **Empty habit list**: Return 200 with empty array
- **Concurrent habit completions**: Use database transaction isolation to prevent duplicates

---

## Performance Considerations

### 1. Database Query Optimization
- Use `select_related()` and `prefetch_related()` in repositories to avoid N+1 queries
- Example: When fetching habits with logs, prefetch logs in single query

### 2. Caching
- Cache frequently accessed data (user profiles, habit lists) using Redis
- Set reasonable TTLs (e.g., 5 minutes for habit lists)
- Invalidate cache on writes

### 3. Async Execution
- All service methods already async-compatible
- Use `asyncio.gather()` for parallel service calls (e.g., fetching multiple habits)

### 4. Response Pagination
- Default limit: 20 items
- Max limit: 100 items
- Use cursor-based pagination for large datasets

---

## Migration & Backward Compatibility

### Coexistence with Telegram Bot
- API and bot share the same Django ORM models and service layer
- No migration needed for existing data
- Both can run simultaneously without conflicts
- Users can interact via both Telegram and API

### Deployment Strategy
1. Deploy API alongside existing bot (same server or separate)
2. Test API with internal users/devices
3. Gradually roll out to mobile/web clients
4. Monitor for issues, rollback if needed

---

## Documentation

### 1. OpenAPI/Swagger
- Auto-generated at `/api/docs` (Swagger UI)
- Auto-generated at `/api/redoc` (ReDoc)
- OpenAPI JSON schema at `/api/openapi.json`

### 2. README Updates
Add section on API usage:
- Authentication flow
- Example cURL commands
- Link to Swagger docs
- Rate limiting information

### 3. Postman Collection
Export OpenAPI schema and import into Postman for easy testing

---

## Implementation Phases Summary

**Phase 1: Foundation** (Estimated 2-3 days)
- Set up FastAPI app structure
- Implement JWT authentication
- Create auth endpoints
- Basic middleware & exception handling

**Phase 2A: Habit Management** (Estimated 2-3 days)
- User endpoints
- Habit CRUD endpoints
- Habit completion & revert
- Habit logs endpoints

**Phase 2B: Rewards & Streaks** (Estimated 2-3 days)
- Reward CRUD endpoints
- Reward progress & claiming
- Streak endpoints

**Phase 3: Advanced Features** (Estimated 1-2 days)
- Batch operations
- Analytics endpoints
- Rate limiting
- Webhooks (optional)

**Total Estimated Time**: 7-11 days (based on 1 developer working full-time)

---

## Success Criteria

- ✅ All Telegram bot functionality available via REST API
- ✅ Secure authentication with JWT
- ✅ Comprehensive API documentation (OpenAPI)
- ✅ Full test coverage (unit + integration)
- ✅ Mobile/web clients can perform all operations
- ✅ No breaking changes to existing Telegram bot
- ✅ Performance acceptable (< 200ms p95 response time)
