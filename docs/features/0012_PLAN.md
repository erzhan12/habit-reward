# Feature 0012: Telegram Reward Creation Flow

## Overview
- Implement sequential conversational flow for creating new rewards directly from Telegram when the user selects “Rewards ➜ New Reward” or runs `/add_reward`, matching the request: “Rewards button -> New Reward I want to be able to create a new reward via telegram sequentially entering values.”

## Current State Analysis
- src/bot/handlers/reward_handlers.py:274 handles `/add_reward` by replying with `INFO_FEATURE_COMING_SOON` and ends; no conversation states exist for reward creation.
- src/bot/messages.py:32 lacks prompts, error messages, and confirmations for reward creation; only habit prompts exist.
- src/bot/keyboards.py:351 provides a cancel button wired to `cancel_habit_flow`; there are no keyboards aligned with reward type selection, confirmation, or cancel/back specific to rewards.
- src/core/repositories.py:166 exposes `RewardRepository.create`, expecting validated payloads, but no service helper performs uniqueness checks or orchestrates reward creation.
- src/bot/main.py:69 registers `/add_reward` as a simple `CommandHandler`, so menu callbacks rely on the placeholder handler; there is no conversation registration.
- tests/test_bot_handlers.py contains coverage for `my_rewards_command` and `claim_reward_command` but nothing for the `/add_reward` path or reward menus.

## Requirements from User
- Support the feature described verbatim: “Rewards button -> New Reward I want to be able to create a new reward via telegram sequentially entering values.”
- Keep the interaction inside Telegram, guiding the user through each required field in order.

## Technical Design

### Conversation Entry & State Machine
- Define new conversation states inside src/bot/handlers/reward_handlers.py for each step (name, type, weight, pieces required, optional piece value, confirmation). Store interim data in `context.user_data`.
- Replace the current stub with a conversation entry that validates the user per RULES.md, fetches language via `get_message_language_async`, and kicks off the first prompt.
- Build a `ConversationHandler` (`add_reward_conversation`) with entry points for `/add_reward` and the inline callback `menu_rewards_add`; include callbacks for each state transition and `/cancel`. Ensure it is exported and registered in src/bot/main.py ahead of menu handlers so it intercepts callbacks.
- When entered from the Rewards submenu, push the navigation state via `push_navigation` so Back buttons stay consistent with the unified navigation stack.

### Prompt Sequence & Validation
- Step 1 (Name): prompt with HTML-formatted text; strip whitespace; validate non-empty, length ≤ 255, and uniqueness by calling `reward_repository.get_by_name`; show localized errors and re-prompt on failure.
- Step 2 (Type): send inline keyboard with options for `virtual`, `real`, and `none`; map callback payloads to `Reward.RewardType` values and store; enforce selection via buttons only.
- Step 3 (Weight): accept numeric text input while also rendering an inline keyboard with quick-pick buttons for 10-100 in steps of 10; parse to Decimal/float; enforce `> 0` and cap at a reasonable max (e.g., 100) to mirror habit weights; on invalid input send localized error and re-prompt. If a new constant (such as `REWARD_WEIGHT_MAX`) is useful, add it to src/config.py alongside habit limits.
- Step 4 (Pieces Required): prompt for integer count; require integer ≥ 1; re-prompt if invalid and reuse localization for guidance.
- Step 5 (Piece Value optional): allow users to enter decimal value ≥ 0 or tap an inline “Skip” button on the keyboard to leave it blank; store `None` when skipped; validate format and range, surfacing errors through messages.
- Step 6 (Confirmation): summarize captured fields with HTML formatting (escape user input) and offer inline confirmation keyboard (Confirm / Edit / Cancel). On Confirm, call the service to persist; on Edit, jump back to the name step and clear captured fields; on Cancel, exit via cancel handler.

### Cancel & Navigation Behavior
- Add a `cancel_reward_flow_callback` and `/cancel` fallback that clear `context.user_data`, show a localized cancellation message, and return the user to the rewards submenu via `build_rewards_menu_keyboard`.
- Reuse or extend the cancel keyboard builder so the reward flow uses `callback_data="cancel_reward_flow"` (avoid colliding with habit flows). Align Back/Cancel messaging with the navigation stack by editing the original menu message when possible.

### Service & Repository Integration
- Add a helper on `reward_service` (e.g., `create_reward`) that takes the validated payload, performs a final uniqueness check, normalizes types (convert enums and decimals), and delegates to `reward_repository.create`.
- Ensure the handler awaits this helper, handles integrity errors gracefully, logs success with the created reward ID, and clears `context.user_data` after completion.

### Messaging & Localization
- Extend src/bot/messages.py with new constants for prompts, validation errors, confirmation text, success, cancel, skip instructions, and button labels; supply translations for `ru` and `kk` within `_TRANSLATIONS`.
- Replace the obsolete `INFO_FEATURE_COMING_SOON` usage in the add reward path; retain the constant only if it is referenced elsewhere.

### Keyboards & Callbacks
- Add inline keyboard builders in src/bot/keyboards.py for reward type selection, weight quick-pick buttons (10-100 step 10), confirmation, piece-value skip option, success follow-up (e.g., Add Another / Back to Rewards), and the reward-specific cancel button. Ensure labels use `msg(...)` keys.
- Wire new callback handlers in the conversation states to match the keyboard callback data patterns, covering confirm, edit, add-another, and cancel flows.

### Success Flow & Follow-up
- After creation, send a localized success message summarizing the reward and include a keyboard offering options such as “Add Another Reward” (loop back to the name step) and “Back to Rewards Menu” to reinstate navigation.
- Clear any stored context state after finishing or when aborting the flow to avoid leaking data between conversations.

### Testing
- Add async unit tests in tests/test_bot_handlers.py covering user-not-found/inactive cases for `/add_reward` and the initial prompt rendering.
- Add conversation step tests using AsyncMock updates to confirm that valid inputs transition through states and that invalid data triggers the correct error messages.
- Add service-level test(s) in tests/test_reward_service.py to cover the new `create_reward` helper, including duplicate name handling and optional piece value.
