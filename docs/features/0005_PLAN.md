# Feature 0005: Unified Cumulative Reward System

## Description

Unify the reward system so that ALL rewards are cumulative with progress tracking. Non-cumulative rewards will simply have `pieces_required=1`, making them immediately claimable after being awarded. The status workflow will be:

1. **üïí Pending**: `pieces_earned < pieces_required` - User is making progress
2. **‚è≥ Achieved**: `pieces_earned == pieces_required && !claimed` - Ready to claim
3. **‚úÖ Claimed**: `claimed == true` - User has claimed the reward

This eliminates the distinction between cumulative and non-cumulative rewards in the data model and simplifies the reward selection and claiming flow.

## Current System Issues

1. **Dual reward types**: Rewards are split between cumulative (`is_cumulative=true`) and non-cumulative (`is_cumulative=false`)
2. **Inconsistent tracking**: Non-cumulative rewards don't create RewardProgress entries
3. **Broken claiming**: `mark_reward_completed()` in `src/services/reward_service.py:217-222` updates with empty dict `{}`, not actually setting any field
4. **4-state status**: Airtable formula returns "üå± Just started" which isn't in Python enum, causing errors
5. **Missing field**: No `claimed` field exists to track whether user has actually received their reward

## Data Layer Changes

### Airtable Schema Changes

**RewardProgress table**:
- Add new field: `claimed` (Checkbox, default: unchecked)
- Update formula for `status` field:
  ```
  IF(
    {claimed},
    "‚úÖ Claimed",
    IF(
      {pieces_earned} >= {pieces_required},
      "‚è≥ Achieved",
      "üïí Pending"
    )
  )
  ```
- Keep existing fields: `user_id`, `reward_id`, `pieces_earned`
- Keep computed field: `pieces_required` (looks up from linked Reward)

**Rewards table**:
- Remove field: `is_cumulative` (no longer needed)
- Update field: `pieces_required` (now required for ALL rewards, default=1 for instant rewards)
- Keep field: `piece_value` (monetary value per piece)
- Update field: `type` enum values remain same: virtual, real, none

### Python Model Changes

**src/models/reward_progress.py**:
- Add field: `claimed: bool = Field(default=False)`
- Remove status: `JUST_STARTED` is not needed (we're simplifying to 3 states)
- Update status enum: Change `COMPLETED` to `CLAIMED = "‚úÖ Claimed"`
- Keep status enum values: PENDING, ACHIEVED, CLAIMED

**src/models/reward.py**:
- Remove field: `is_cumulative` (all rewards are now cumulative)
- Update field: `pieces_required: int = Field(default=1)` - make required with default=1
- Keep field: `piece_value`
- Remove enum value: `RewardType.CUMULATIVE` (redundant)
- Keep enum values: VIRTUAL, REAL, NONE

## Repository Changes

**src/airtable/repositories.py**:

**RewardProgressRepository**:
- `create()` (line 178): Already fixed - doesn't set `pieces_required` (computed field)
- Add handling for `claimed` field in `_record_to_progress()` (line 221)
- No changes needed to `update()`, `get_by_user_and_reward()`, etc.

**RewardRepository**:
- `create()` (line 120): Remove `is_cumulative` from data dict
- `_record_to_reward()` (line 157): Remove `is_cumulative` field handling
- Ensure `pieces_required` defaults to 1 if not provided

## Service Layer Changes

**src/services/reward_service.py**:

**select_reward()** (line 45):
- Remove logic checking `is_cumulative`
- All rewards now go through same selection process
- No behavioral changes to weighted random selection

**update_cumulative_progress()** (line 141):
- Rename to `update_reward_progress()` (no longer "cumulative"-specific)
- Remove check: `if not reward or not reward.is_cumulative:` (line 170)
- Always create/update RewardProgress entry for ANY reward
- Keep increment logic: `new_pieces = progress.pieces_earned + 1`
- Status will be auto-calculated by Airtable based on formula

**mark_reward_completed()** (line 198):
- Rename method to `mark_reward_claimed()` for clarity
- Fix broken implementation that updates with empty dict `{}`
- Change to: `{"claimed": True}`
- This will trigger Airtable formula to set status to "‚úÖ Claimed"
- Keep validation: `if progress.status != RewardStatus.ACHIEVED:`

**get_todays_awarded_rewards()** (line 112):
- No changes needed
- Already excludes all rewards awarded today (prevents duplicates)

**Remove method**:
- `set_reward_status()` (line 224) - No longer needed, status is fully computed

**src/services/habit_service.py**:

**process_habit_completion()** (line 32):
- Line 104-109: Remove conditional `if selected_reward.is_cumulative and got_reward:`
- Change to: Always call `update_reward_progress()` for ANY reward (including "none" type)
- Logic:
  ```python
  # Update progress for ALL rewards (even type=none with pieces_required=1)
  reward_progress = None
  if got_reward:  # got_reward means type != NONE
      reward_progress = self.reward_service.update_reward_progress(
          user_id=user.id,
          reward_id=selected_reward.id
      )
  ```

## Bot Handler Changes

**src/bot/handlers/reward_handlers.py**:

**claim_reward_callback()** (line 162):
- Line 191: Rename call from `mark_reward_completed()` to `mark_reward_claimed()`
- Will now correctly set `claimed=True`
- No other changes needed

**rewards_progress_command()** (line 73):
- No changes needed
- Will show all RewardProgress entries (now includes all rewards)

## Formatter Changes

**src/bot/formatters.py**:

**format_habit_completion_message()** (line 11):
- Line 26-35: Remove conditional `if result.reward.is_cumulative:`
- Always show progress for ANY reward:
  ```python
  if result.got_reward and result.cumulative_progress:
      # Show progress (X/Y pieces)
      if result.cumulative_progress.status == RewardStatus.ACHIEVED:
          # Show "Ready to claim!" message
  ```

**format_claim_success_with_progress()** (line 68):
- No changes needed

**format_reward_progress_message()** (line 89):
- No changes needed

## Algorithm: Unified Reward Flow

### When Habit is Completed:
1. Select reward using weighted random (existing logic)
2. If reward type != NONE:
   - Get or create RewardProgress for (user, reward)
   - Increment `pieces_earned` by 1
   - Airtable formula calculates status:
     - If `pieces_earned >= pieces_required`: status = "‚è≥ Achieved"
     - Else: status = "üïí Pending"
3. Log to HabitLog with reward_id
4. Show user their progress (X/Y pieces)

### When User Claims Reward:
1. Validate: `progress.status == RewardStatus.ACHIEVED`
2. Update: `{"claimed": True}`
3. Airtable formula updates status to "‚úÖ Claimed"
4. Show success message

### Instant Rewards (Previously "Non-cumulative"):
- `pieces_required = 1`
- After awarded once: `pieces_earned = 1`
- Status immediately becomes "‚è≥ Achieved" (ready to claim)
- User can claim right away

### Multi-piece Rewards (Previously "Cumulative"):
- `pieces_required > 1` (e.g., 10)
- After each award: `pieces_earned += 1`
- Status stays "üïí Pending" until `pieces_earned == pieces_required`
- Then becomes "‚è≥ Achieved"

## Files to Modify

### Data Models:
- `src/models/reward.py` - Remove `is_cumulative`, update `pieces_required`
- `src/models/reward_progress.py` - Add `claimed` field

### Repositories:
- `src/airtable/repositories.py` - Update RewardRepository and RewardProgressRepository

### Services:
- `src/services/reward_service.py` - Rename/refactor cumulative methods, fix mark_reward_completed
- `src/services/habit_service.py` - Always update progress for all rewards

### Bot Handlers:
- `src/bot/formatters.py` - Remove is_cumulative conditionals

### Tests:
- `tests/test_reward_service.py` - Update for unified system
- `tests/test_habit_service.py` - Update test expectations

## Migration Notes

**Airtable manual steps**:
1. Add `claimed` checkbox field to RewardProgress table
2. Update `status` formula in RewardProgress table
3. Update all existing Rewards: set `pieces_required=1` where currently `is_cumulative=false`
4. (Optional) Remove `is_cumulative` field from Rewards table after code deployment

**Data migration**:
- Existing RewardProgress entries: `claimed` defaults to `false` (unchecked)
- Rewards with `is_cumulative=false`: Set `pieces_required=1`
- No changes to existing logs or user data
