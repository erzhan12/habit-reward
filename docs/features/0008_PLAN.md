# Feature 0008: Unified Back Button Navigation Flow

## Overview

Implement a consistent "Back" button navigation system for all menu screens and command outputs. When users interact with any menu button or command, the original menu message should be replaced with the new content. Each screen (except the main menu) should include a "Back" button that returns to the previous menu by editing the message in-place rather than sending new messages.

## Current State Analysis

### Existing Navigation Components

**Menu System (src/bot/handlers/menu_handler.py:1-171)**:
- `open_start_menu_callback()` - Edits message to show main menu
- `open_habits_menu_callback()` - Edits message to show habits submenu
- `open_rewards_menu_callback()` - Edits message to show rewards submenu
- `close_menu_callback()` - Deletes the menu message
- `bridge_command_callback()` - Routes menu button clicks to command handlers by creating synthetic Update objects with MockMessage class

**Keyboard Builders (src/bot/keyboards.py:285-352)**:
- `build_start_menu_keyboard()` - Main menu with 5 rows: Habit Done, [Habits/Rewards], Claim Reward, [Streaks/Settings], [Help/Close]
- `build_habits_menu_keyboard()` - Submenu with Add/Edit/Remove habit buttons + Back button (callback: `menu_back_start`)
- `build_rewards_menu_keyboard()` - Submenu with Add/List/My/Claim reward buttons + Back button (callback: `menu_back_start`)

**Start Command (src/bot/main.py:33-81)**:
- Validates user existence and active status
- Sends welcome message with `build_start_menu_keyboard()`
- Uses `parse_mode="HTML"`

**Help Command (src/bot/main.py:83-115)**:
- Validates user existence and active status
- Sends help text from `msg('HELP_COMMAND_MESSAGE', lang)`
- Currently does NOT include a "Back" button

### Current Navigation Flow Issues

1. **Command handlers send new messages** instead of editing existing ones:
   - When user clicks menu buttons, `bridge_command_callback()` creates MockMessage that redirects `reply_text()` to `send_message()`
   - This works but creates new messages instead of editing in-place
   - No "Back" button is shown after command execution

2. **Help and other commands don't have Back buttons**:
   - User must use /start to get back to menu
   - No inline keyboard for navigation

3. **Inconsistent message flow**:
   - Submenus edit messages (good)
   - Command outputs create new messages (inconsistent)
   - No way to return to menu from command output

## Requirements from User

1. User enters `/start` → Gets welcoming message with command buttons
2. User presses any button (e.g., "Help") → Welcoming message **replaces** with help message + "Back" button
3. User presses "Back" → Help message **replaces** back to welcoming message with all buttons
4. Same pattern applies to ALL menu buttons and command outputs
5. Every screen except the main menu should have a "Back" button

## Technical Design

### Phase 1: Message State Management

**Create Navigation Context Manager**

New file: `src/bot/navigation.py`

Purpose: Track navigation history and manage message editing for seamless back navigation.

Key components:
- Store message_id and chat_id in `context.user_data['navigation_stack']`
- Stack structure: `[{'message_id': int, 'menu_type': str, 'lang': str}]`
- Methods:
  - `push_navigation(context, message_id, menu_type, lang)` - Add new nav state
  - `pop_navigation(context)` - Remove current state, return previous
  - `get_current_navigation(context)` - Get current state without popping
  - `clear_navigation(context)` - Reset stack (on /start)

### Phase 2: Update Menu Handlers

**Modify menu_handler.py (src/bot/handlers/menu_handler.py)**

Changes to callback handlers:
- `open_start_menu_callback()` (line 18) - Push 'start' to navigation stack
- `open_habits_menu_callback()` (line 33) - Push 'habits' to navigation stack
- `open_rewards_menu_callback()` (line 48) - Push 'rewards' to navigation stack
- All handlers: Store message_id after edit

**Create generic back handler**:
```python
async def generic_back_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle back button from any screen."""
    query = update.callback_query
    await query.answer()

    # Pop current state and get previous
    prev_state = pop_navigation(context)

    if not prev_state or prev_state['menu_type'] == 'start':
        # Return to start menu
        await open_start_menu_callback(update, context)
    elif prev_state['menu_type'] == 'habits':
        await open_habits_menu_callback(update, context)
    elif prev_state['menu_type'] == 'rewards':
        await open_rewards_menu_callback(update, context)
```

Register handler pattern: `^menu_back$` (generic back button)

### Phase 3: Add Back Buttons to Command Outputs

**Update keyboard builders (src/bot/keyboards.py)**

Add new keyboard builder:
```python
def build_back_to_menu_keyboard(language: str = 'en') -> InlineKeyboardMarkup:
    """Build keyboard with only a Back button to return to main menu."""
    keyboard = [
        [InlineKeyboardButton(
            text=msg('MENU_BACK', language),
            callback_data="menu_back"
        )]
    ]
    return InlineKeyboardMarkup(keyboard)
```

**Modify command handlers to include Back button**:

Files to modify:
1. `src/bot/main.py` - `help_command()` (line 83)
2. `src/bot/handlers/streak_handler.py` - `streaks_command()`
3. Other command handlers that don't start conversations

Changes:
- Add `reply_markup=build_back_to_menu_keyboard(lang)` parameter to `reply_text()` calls
- Ensure all output messages include the Back button keyboard

### Phase 4: Replace Messages Instead of Sending New Ones

**Update bridge_command_callback (src/bot/handlers/menu_handler.py:73-157)**

Current approach: MockMessage redirects `reply_text()` to `send_message()` creating new messages.

New approach: Modify MockMessage to edit existing menu message instead:

```python
class MockMessage:
    def __init__(self, original_message, user, should_edit=True):
        self._original = original_message
        self._should_edit = should_edit
        # ... existing fields ...

    async def reply_text(self, text, **kwargs):
        """Edit original message or send new message."""
        if self._should_edit and self._original:
            # Edit the menu message in-place
            return await self._original.edit_text(
                text=text,
                **kwargs
            )
        else:
            # Fallback: send new message
            return await self.chat.send_message(text=text, **kwargs)
```

This ensures all command outputs replace the menu message instead of creating new ones.

### Phase 5: Handle Conversation Handlers

**Special case: ConversationHandler flows**

Conversation-based commands (habit_done, claim_reward, add_habit, etc.) use multi-step flows that require multiple messages.

Strategy:
1. First message (entry point) should edit the menu message
2. Subsequent conversation messages can be new messages (expected behavior)
3. On conversation end (ConversationHandler.END), include Back button to return to menu
4. On cancel, edit back to start menu

**Files with ConversationHandlers**:
- `src/bot/handlers/habit_done_handler.py` - `habit_done_conversation`
- `src/bot/handlers/habit_management_handler.py` - `add_habit_conversation`, `edit_habit_conversation`, `remove_habit_conversation`
- `src/bot/handlers/reward_handlers.py` - `claim_reward_conversation`
- `src/bot/handlers/settings_handler.py` - `settings_conversation`

Modifications:
- Entry point functions: Use `query.edit_message_text()` when triggered from menu
- Cancel handlers: Edit message back to start menu with `open_start_menu_callback()`
- Final messages: Include `build_back_to_menu_keyboard()`

### Phase 6: Update Message Constants

**Add new message keys (src/bot/messages.py)**

No new message constants needed - reuse existing:
- `MENU_BACK` (line 60) - Already exists for "« Back"
- `START_MENU_TITLE` (line 57) - Already exists
- `HELP_COMMAND_MESSAGE` (line 80) - Already exists

## Files to Modify

### New Files
1. **src/bot/navigation.py** - Navigation state management

### Modified Files
1. **src/bot/handlers/menu_handler.py**
   - Update all menu callback handlers to manage navigation stack
   - Add `generic_back_callback()` function
   - Modify `MockMessage.reply_text()` to edit instead of send
   - Register new back button handler in `get_menu_handlers()`

2. **src/bot/keyboards.py**
   - Add `build_back_to_menu_keyboard()` function

3. **src/bot/main.py**
   - `help_command()`: Add `build_back_to_menu_keyboard()` to reply
   - `start_command()`: Clear navigation stack on start

4. **src/bot/handlers/streak_handler.py**
   - `streaks_command()`: Add Back button to output

5. **src/bot/handlers/habit_done_handler.py**
   - Entry point: Edit message when called from menu
   - Cancel handler: Return to start menu
   - Final message: Add Back button

6. **src/bot/handlers/habit_management_handler.py**
   - All conversation entry points: Edit message when from menu
   - All cancel handlers: Return to start menu
   - All final messages: Add Back button

7. **src/bot/handlers/reward_handlers.py**
   - `list_rewards_command()`: Add Back button
   - `my_rewards_command()`: Add Back button
   - Conversation entry points: Edit when from menu
   - Final messages: Add Back button

8. **src/bot/handlers/settings_handler.py**
   - Already has Back button in language selection (line 164)
   - Update cancel handler to return to start menu

## Implementation Algorithm

### Navigation Stack Algorithm

**Push navigation state (when entering new menu/screen)**:
```
1. Get current context.user_data
2. Initialize 'navigation_stack' if not exists (empty list)
3. Append {'message_id': message_id, 'menu_type': menu_type, 'lang': lang}
4. Store back to context.user_data
```

**Pop navigation state (when pressing Back)**:
```
1. Get navigation_stack from context.user_data
2. If stack empty: return {'menu_type': 'start', 'lang': 'en'}
3. Pop last item from stack
4. If stack now empty: return {'menu_type': 'start', 'lang': detected_lang}
5. Return popped item
```

**Clear navigation (on /start command)**:
```
1. Set context.user_data['navigation_stack'] = []
```

### Message Editing Flow Algorithm

**When menu button clicked**:
```
1. User clicks menu button → callback_query triggered
2. query.answer() to acknowledge button press
3. Push current navigation state to stack
4. Edit message with query.edit_message_text(new_content, new_keyboard)
5. Return navigation state or ConversationHandler state
```

**When Back button clicked**:
```
1. User clicks "Back" button → callback_query with "menu_back" or "menu_back_start"
2. query.answer() to acknowledge
3. Pop navigation stack to get previous menu
4. Edit message back to previous menu using query.edit_message_text()
5. Return appropriate state
```

**When command executes from menu**:
```
1. bridge_command_callback creates MockMessage
2. MockMessage.reply_text() called by command handler
3. Instead of sending new message:
   a. Get original message from query
   b. Call message.edit_text() with command output
   c. Add build_back_to_menu_keyboard() to inline keyboard
4. Return command result
```

## Edge Cases & Error Handling

1. **Message too old to edit** (>48 hours):
   - Catch `telegram.error.BadRequest: Message can't be edited`
   - Fallback: Send new message with content + Back button

2. **Message already deleted**:
   - Catch `telegram.error.BadRequest: Message to edit not found`
   - Fallback: Send new message

3. **Navigation stack corrupted**:
   - Always provide fallback to start menu
   - Clear stack on errors

4. **User types /start mid-conversation**:
   - Clear navigation stack
   - End any active conversations
   - Show fresh start menu

## Testing Checklist

Manual testing scenarios:
- [ ] /start → Welcome menu appears
- [ ] Click "Help" → Menu edits to help text with Back button
- [ ] Click "Back" → Returns to welcome menu (edits message)
- [ ] Click "Habits" → Submenu appears (edits message)
- [ ] Click "Add Habit" → Submenu edits to conversation start
- [ ] Cancel conversation → Returns to start menu (edits message)
- [ ] Click "Streaks" → Output shows with Back button
- [ ] Click "Back" from streaks → Returns to start menu
- [ ] Click multiple submenus → Back always returns correctly
- [ ] Close menu → Message deleted

## Notes

- This feature enhances UX by reducing message clutter
- All navigation happens via message editing (no new messages)
- Back button is consistent across all screens
- Navigation stack allows complex menu hierarchies in future
- Pattern follows Telegram bot best practices for inline keyboards
