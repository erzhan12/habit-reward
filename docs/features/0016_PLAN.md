# Multi-User Support: User Field in Habits and Rewards

## Context
Currently, habits and rewards are shared globally across all users. This feature introduces true multi-user support by associating habits and rewards with specific users, ensuring data isolation.

## Affected Files
- `src/core/models.py`
- `src/core/migrations/`
- `src/core/repositories.py`
- `src/services/habit_service.py`
- `src/services/reward_service.py`
- `src/bot/handlers/habit_management_handler.py`
- `src/bot/handlers/reward_handlers.py`
- `src/core/admin.py`

## Technical Implementation

### Phase 1: Data Layer
1.  **Modify `Habit` model in `src/core/models.py`**:
    -   Add `user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='habits')`.
    -   Update `Meta` indexes to include `user`.
    -   Update `unique` constraint for `name` to be unique per user (`unique_together = ['user', 'name']`).

2.  **Modify `Reward` model in `src/core/models.py`**:
    -   Add `user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='rewards')`.
    -   Update `Meta` indexes to include `user`.
    -   Update `unique` constraint for `name` to be unique per user (`unique_together = ['user', 'name']`).

3.  **Migrations**:
    -   Create a migration that adds the fields as nullable first.
    -   Run a data migration to assign existing habits/rewards to a default user (e.g., first superuser or active user) to preserve existing data.
    -   Alter fields to be non-nullable.

4.  **Admin Panel (`src/core/admin.py`)**:
    -   Update `HabitAdmin` and `RewardAdmin` to display `user`.
    -   Add `user` to `list_filter`.
    -   Override `save_model` or `get_queryset` if necessary to assist with admin-created items (though admin is usually superuser).

### Phase 2: Service & Repository Layer
1.  **Update `HabitRepository` in `src/core/repositories.py`**:
    -   Update `get_all_active` to accept `user_id` and filter by it.
    -   Update `get_by_name` to accept `user_id` and filter by it.
    -   Update `create` to accept `user_id` and set it.
    -   Update `get_by_id` to optionally verify user ownership (or rely on service layer).

2.  **Update `RewardRepository` in `src/core/repositories.py`**:
    -   Update `get_all_active` to accept `user_id` and filter by it.
    -   Update `get_by_name` to accept `user_id` and filter by it.
    -   Update `create` to accept `user_id` and set it.

3.  **Update `HabitService` in `src/services/habit_service.py`**:
    -   Update `get_all_active_habits` to require `user_id`.
    -   Update `get_habit_by_name` to require `user_id` (if applicable).
    -   Update `get_active_habits_pending_for_today` to pass `user_id` to repo calls.

4.  **Update `RewardService` in `src/services/reward_service.py`**:
    -   Update `select_reward` to use `user_id` when fetching active rewards.
    -   Update `get_active_rewards` to require `user_id`.
    -   Update `create_reward` to require `user_id`.

### Phase 3: Bot Handlers
1.  **Update `src/bot/handlers/habit_management_handler.py`**:
    -   In `add_habit_command`, pass `user.id` to creation logic.
    -   In `edit_habit_command` / `remove_habit_command`, pass `user.id` when fetching habits.
    -   Update validation to check name uniqueness *per user*.

2.  **Update `src/bot/handlers/reward_handlers.py`**:
    -   In `add_reward_command`, pass `user.id` to creation logic.
    -   In `list_rewards_command`, pass `user.id` to fetch logic.
    -   In `claim_reward_command`, ensure rewards being claimed belong to user (implicit via progress, but good to verify).

### Security Implications
-   Ensure all database queries for user-facing content are scoped by `user_id`.
-   Prevent cross-user access by validating ownership in services/repositories.

