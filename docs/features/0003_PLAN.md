# Feature 0003: Prevent Duplicate Reward Awards on Same Day

## Context

Currently, the system allows the same reward (both cumulative and non-cumulative) to be awarded multiple times in the same day when different habits are completed. The user has requested to add logic that prevents duplicate reward awards within the same day.

**Key Requirements:**
1. For **non-cumulative** rewards (`is_cumulative=False`): If awarded today already, the same reward **cannot** be awarded again on the same day
2. For **cumulative** rewards (`is_cumulative=True`): User **cannot earn pieces multiple times per day** - if a cumulative reward is awarded today already, it cannot be awarded again the same day
3. Both types of rewards can only be awarded once per day maximum

## Current Behavior

The reward system currently:
- Performs weighted random selection for each habit completion (src/services/reward_service.py:44-81)
- Awards cumulative rewards multiple times per day (incrementing pieces_earned each time)
- Awards non-cumulative rewards multiple times per day if randomly selected
- Has NO duplicate prevention for any type of reward
- Tracks all reward awards in HabitLog table with timestamps

The only duplicate prevention that exists is in the streak calculation (src/services/streak_service.py:14-52), which prevents the same habit from being completed multiple times in one day from incrementing the streak - but this does NOT prevent multiple reward awards.

## Files to Modify

### 1. `src/services/reward_service.py`

**New Method:** `get_todays_awarded_rewards(user_id: str) -> list[str]`
- Query HabitLog for today's entries for this user
- Filter for entries where `got_reward=True` and `reward_id` is not null
- Return list of ALL reward IDs that were awarded today (both cumulative and non-cumulative)
- This ensures no reward can be awarded twice in the same day
- Location: After `select_reward()` method (around line 82)

**Modified Method:** `select_reward(total_weight: float, user_id: str, exclude_reward_ids: list[str] = None) -> Reward`
- Add `user_id` parameter (required for checking user's today awards)
- Add optional `exclude_reward_ids` parameter (list of reward IDs to exclude from selection)
- Fetch all active rewards as before
- **Filter out** any rewards whose IDs are in `exclude_reward_ids` list
- If all rewards are filtered out, return a "none" reward
- Perform weighted random selection on remaining rewards
- Location: src/services/reward_service.py:44-81

### 2. `src/services/habit_service.py`

**Modified Method:** `process_habit_completion(user_telegram_id: str, habit_name: str) -> HabitCompletionResult`

Algorithm changes (around line 88):
1. Calculate total_weight as before
2. **NEW:** Call `reward_service.get_todays_awarded_rewards(user.id)` to get list of ALL reward IDs already awarded today (both cumulative and non-cumulative)
3. Call `reward_service.select_reward(total_weight, user_id=user.id, exclude_reward_ids=todays_rewards)` with exclusion list
4. Process selected reward as before (cumulative progress, logging, etc.)
5. Note: For cumulative rewards, this means pieces can only be earned once per day

Location: src/services/habit_service.py:88

### 3. `src/airtable/repositories.py`

**New Method in `HabitLogRepository`:** `get_todays_logs_by_user(user_id: str, target_date: date = None) -> list[HabitLog]`
- Query HabitLog table filtered by user_id
- Filter by `last_completed_date` matching today (or target_date if provided)
- Return list of HabitLog entries
- Location: After `get_logs_by_user()` method (around line 287)

## Algorithm: Duplicate Prevention Logic

```
When user completes a habit:
  1. Calculate total_weight from habit_weight and streak

  2. Get today's reward exclusions:
     a. Query HabitLog for today's entries (last_completed_date == today)
     b. Filter for entries where got_reward=True AND reward_id is not null
     c. Collect ALL reward IDs (both cumulative and non-cumulative) into exclusion list
     d. This ensures no reward can be earned twice in the same day

  3. Select reward with exclusions:
     a. Get all active rewards
     b. Filter OUT any rewards in exclusion list
     c. If no rewards remain: return type="none" reward
     d. Perform weighted random selection on remaining rewards

  4. Process selected reward as usual:
     - If cumulative: update progress (can only earn 1 piece per day now)
     - If non-cumulative: award directly (can only be awarded once per day)
     - Log in HabitLog
```

## Edge Cases & Considerations

1. **All rewards already awarded today:**
   - If user has completed enough habits today to earn all available rewards
   - System will only have "none" rewards left to select
   - User gets no reward, but habit completion is still logged

2. **Only "none" rewards left:**
   - System returns type="none" reward
   - User gets no reward, but habit completion is logged
   - Streak continues to increment

3. **Timezone handling:**
   - Uses `last_completed_date` field (date, not datetime) for day comparison
   - All date comparisons use `date.today()` which uses server timezone

4. **Performance:**
   - Additional query per habit completion (get today's logs)
   - Mitigated by filtering on user_id and date (indexed fields)
   - Expected impact: ~50-100ms additional latency per habit completion

5. **Race conditions:**
   - If two habits are completed simultaneously, both might query before either writes
   - Airtable doesn't support transactions, so this is acceptable
   - Worst case: same reward awarded twice in rapid succession (rare)

6. **Cumulative reward behavior change:**
   - **IMPORTANT:** This changes cumulative reward mechanics significantly
   - Previously: User could earn multiple pieces per day (complete 5 habits = earn up to 5 pieces)
   - Now: User can only earn 1 piece per day maximum (complete 5 habits = earn 1 piece max)
   - This makes cumulative rewards take longer to complete
   - Example: 10-piece reward previously could be earned in 2 days (5 habits each day), now takes minimum 10 days

7. **User experience impact:**
   - Users who complete many habits per day will see diminishing returns after the first few completions
   - Once all unique rewards are exhausted for the day, subsequent habits yield no new rewards
   - This encourages spreading habit completions across multiple days rather than batching

## Testing Strategy

**Manual Testing Scenarios:**
1. Complete habit A, get non-cumulative reward X
2. Complete habit B same day, verify reward X is excluded from selection
3. Complete habit C, verify can get different non-cumulative reward Y (or cumulative reward Z)
4. Complete habit D same day, if got cumulative reward Z in step 3, verify Z is excluded from selection
5. Complete enough habits to exhaust all rewards, verify subsequent habits return "none" reward
6. Wait until next day, verify all rewards (including X and Z) can be awarded again

**Cumulative Reward Testing:**
1. Complete habit, earn cumulative reward piece (pieces_earned = 1)
2. Complete different habit same day, verify same cumulative reward is NOT selected again
3. Verify pieces_earned did NOT increment to 2
4. Next day, complete habit, verify can earn another piece of same cumulative reward
5. Verify pieces_earned increments to 2

**Data Validation:**
- Check HabitLog entries have correct last_completed_date
- Verify exclusion list contains ALL awarded rewards (both cumulative and non-cumulative)
- Confirm pieces_earned for cumulative rewards only increments once per day

## Files Summary

| File | Changes | Lines |
|------|---------|-------|
| src/services/reward_service.py | Add new method, modify select_reward signature & logic | ~40 lines added |
| src/services/habit_service.py | Add exclusion list lookup, pass to select_reward | ~5 lines modified |
| src/airtable/repositories.py | Add get_todays_logs_by_user method | ~20 lines added |

Total estimated changes: ~65 lines of code
